import { Subject, BehaviorSubject, timer, of, combineLatest, Subscription } from 'rxjs';
import { tap, map, skip, delay, filter, debounce, switchMap, distinctUntilChanged } from 'rxjs/operators';
import { InjectionToken, Injectable, Inject, Optional, NgModule, Component, Input, Output, ChangeDetectionStrategy, EventEmitter, ViewEncapsulation, defineInjectable, inject } from '@angular/core';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class NgProgressRef {
    /**
     * @param {?} customConfig
     * @param {?} deleteInstance
     */
    constructor(customConfig, deleteInstance) {
        this.deleteInstance = deleteInstance;
        /**
         * Stream that increments and updates progress state
         */
        this._trickling = new Subject();
        /**
         * Stream that combines "_trickling" and "config" streams
         */
        this._worker = Subscription.EMPTY;
        this._state = new BehaviorSubject({ active: false, value: 0 });
        this._config = new BehaviorSubject(customConfig);
        this.state = this._state.asObservable();
        this.config = this._state.asObservable();
        this._worker = combineLatest(this._trickling, this._config).pipe(debounce(([start, config]) => timer(start ? config.debounceTime : 0)), switchMap(([start, config]) => start ? this.onTrickling(config) : this.onComplete(config))).subscribe();
    }
    /**
     * Get current progress state
     * @return {?}
     */
    get currState() {
        return this._state.value;
    }
    /**
     * Check if progress has started
     * @return {?}
     */
    get isStarted() {
        return this.currState.active;
    }
    /**
     * Progress start event
     * @return {?}
     */
    get started() {
        return this._state.pipe(map((state) => state.active), distinctUntilChanged(), filter(active => active));
    }
    /**
     * Progress ended event
     * @return {?}
     */
    get completed() {
        return this._state.pipe(map((state) => state.active), distinctUntilChanged(), filter(active => !active), skip(1));
    }
    /**
     * Start the progress
     * @return {?}
     */
    start() {
        this._trickling.next(true);
    }
    /**
     * Complete the progress
     * @return {?}
     */
    complete() {
        this._trickling.next(false);
    }
    /**
     * Increment the progress
     * @param {?=} amount
     * @return {?}
     */
    inc(amount) {
        /** @type {?} */
        const n = this.currState.value;
        if (!this.isStarted) {
            this.start();
        }
        else {
            if (typeof amount !== 'number') {
                amount = this._config.value.trickleFunc(n);
            }
            this.set(n + amount);
        }
    }
    /**
     * Set the progress
     * @param {?} n
     * @return {?}
     */
    set(n) {
        this.setState({ value: this.clamp(n), active: true });
    }
    /**
     * Set config
     * @param {?} config
     * @return {?}
     */
    setConfig(config) {
        this._config.next(Object.assign({}, this._config.value, config));
    }
    /**
     * Destroy progress reference
     * @return {?}
     */
    destroy() {
        this._worker.unsubscribe();
        this._trickling.complete();
        this._state.complete();
        this._config.complete();
        this.deleteInstance();
    }
    /**
     * Set progress state
     * @param {?} state
     * @return {?}
     */
    setState(state) {
        this._state.next(Object.assign({}, this.currState, state));
    }
    /**
     * Clamps a value to be between min and max
     * @param {?} n
     * @return {?}
     */
    clamp(n) {
        return Math.max(this._config.value.min, Math.min(this._config.value.max, n));
    }
    /**
     * Keeps incrementing the progress
     * @param {?} config
     * @return {?}
     */
    onTrickling(config) {
        if (!this.isStarted) {
            this.set(this._config.value.min);
        }
        return timer(0, config.trickleSpeed).pipe(tap(() => this.inc()));
    }
    /**
     * Completes then resets the progress
     * @param {?} config
     * @return {?}
     */
    onComplete(config) {
        return !this.isStarted ? of({}) : of({}).pipe(
        // Completes the progress
        tap(() => this.setState({ value: 100 })), 
        // Hides the progress bar after a tiny delay
        delay(config.speed * 1.7), tap(() => this.setState({ active: false })), 
        // Resets the progress state
        delay(config.speed), tap(() => this.setState({ value: 0 })));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const CONFIG = new InjectionToken('config');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
const ɵ0 = (n) => {
    if (n >= 0 && n < 20)
        return 10;
    if (n >= 20 && n < 50)
        return 4;
    if (n >= 50 && n < 80)
        return 2;
    if (n >= 80 && n < 99)
        return 0.5;
    return 0;
};
/** @type {?} */
const defaultConfig = {
    min: 8,
    max: 100,
    speed: 200,
    debounceTime: 0,
    trickleSpeed: 300,
    fixed: true,
    meteor: true,
    thick: false,
    spinner: true,
    ease: 'linear',
    color: '#1B95E0',
    direction: 'ltr+',
    spinnerPosition: 'right',
    trickleFunc: ɵ0
};
class NgProgress {
    /**
     * @param {?} config
     */
    constructor(config) {
        /**
         * Store progress bar instances
         */
        this._instances = new Map();
        this.config = Object.assign({}, defaultConfig, config);
    }
    /**
     * Get or Create progress bar by ID
     * @param {?=} id
     * @param {?=} config
     * @return {?}
     */
    ref(id = 'root', config) {
        if (this._instances.has(id)) {
            /** @type {?} */
            const progressRef = this._instances.get(id);
            if (config) {
                progressRef.setConfig(Object.assign({}, this.config, config));
            }
            return progressRef;
        }
        else {
            /** @type {?} */
            const progressRef = new NgProgressRef(Object.assign({}, this.config, config), this.deleteInstance(id));
            return this._instances.set(id, progressRef).get(id);
        }
    }
    /**
     * Destroy all progress bar instances
     * @return {?}
     */
    destroyAll() {
        this._instances.forEach((ref) => ref.destroy());
    }
    /**
     * A destroyer function for each progress bar instance
     * @param {?} id
     * @return {?}
     */
    deleteInstance(id) {
        return () => {
            this._instances.delete(id);
        };
    }
}
NgProgress.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
NgProgress.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CONFIG,] }] }
];
/** @nocollapse */ NgProgress.ngInjectableDef = defineInjectable({ factory: function NgProgress_Factory() { return new NgProgress(inject(CONFIG, 8)); }, token: NgProgress, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class NgProgressComponent {
    /**
     * @param {?} _ngProgress
     */
    constructor(_ngProgress) {
        this._ngProgress = _ngProgress;
        this._started = Subscription.EMPTY;
        this._completed = Subscription.EMPTY;
        /**
         * Creates a new instance if id is not already exists
         */
        this.id = 'root';
        /**
         * Initializes inputs from the global config
         */
        this.min = this._ngProgress.config.min;
        this.max = this._ngProgress.config.max;
        this.ease = this._ngProgress.config.ease;
        this.color = this._ngProgress.config.color;
        this.speed = this._ngProgress.config.speed;
        this.thick = this._ngProgress.config.thick;
        this.fixed = this._ngProgress.config.fixed;
        this.meteor = this._ngProgress.config.meteor;
        this.spinner = this._ngProgress.config.spinner;
        this.trickleSpeed = this._ngProgress.config.trickleSpeed;
        this.debounceTime = this._ngProgress.config.debounceTime;
        this.trickleFunc = this._ngProgress.config.trickleFunc;
        this.spinnerPosition = this._ngProgress.config.spinnerPosition;
        this.direction = this._ngProgress.config.direction;
        this.started = new EventEmitter();
        this.completed = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get isStarted() {
        return this.progressRef.isStarted;
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        if (this.progressRef instanceof NgProgressRef) {
            // Update progress bar config when inputs change
            this.progressRef.setConfig({
                max: (this.max > 0 && this.max <= 100) ? this.max : 100,
                min: (this.min < 100 && this.min >= 0) ? this.min : 0,
                speed: this.speed,
                trickleSpeed: this.trickleSpeed,
                trickleFunc: this.trickleFunc,
                debounceTime: this.debounceTime
            });
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Get progress bar service instance
        this.progressRef = this._ngProgress.ref(this.id, {
            max: this.max,
            min: this.min,
            speed: this.speed,
            trickleSpeed: this.trickleSpeed,
            debounceTime: this.debounceTime
        });
        // Subscribe to progress state
        this.state$ = this.progressRef.state.pipe(map((state) => ({
            active: state.active,
            transform: `translate3d(${state.value}%,0,0)`
        })));
        // Subscribes to started and completed events on deman
        if (this.started.observers.length) {
            this._started = this.progressRef.started.subscribe(() => this.started.emit());
        }
        if (this.completed.observers.length) {
            this._completed = this.progressRef.completed.subscribe(() => this.completed.emit());
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._started.unsubscribe();
        this._completed.unsubscribe();
        this.progressRef.destroy();
    }
    /**
     * @return {?}
     */
    start() {
        this.progressRef.start();
    }
    /**
     * @return {?}
     */
    complete() {
        this.progressRef.complete();
    }
    /**
     * @param {?=} n
     * @return {?}
     */
    inc(n) {
        this.progressRef.inc(n);
    }
    /**
     * @param {?} n
     * @return {?}
     */
    set(n) {
        this.progressRef.set(n);
    }
}
NgProgressComponent.decorators = [
    { type: Component, args: [{
                selector: 'ng-progress',
                host: {
                    'role': 'progressbar',
                    '[attr.spinnerPosition]': 'spinnerPosition',
                    '[attr.dir]': 'direction',
                    '[attr.thick]': 'thick',
                    '[attr.fixed]': 'fixed'
                },
                template: `
    <ng-container *ngIf="state$ | async; let state">
      <div class="ng-progress-bar"
            [class.-active]="state.active"
            [style.transition]="'opacity ' + speed + 'ms ' + ease">
        <div class="ng-bar-placeholder">
          <div class="ng-bar"
                [style.transform]="state.transform"
                [style.backgroundColor]="color"
                [style.transition]="state.active ? 'all ' + speed + 'ms ' + ease : 'none'">
            <div *ngIf="meteor" class="ng-meteor" [style.boxShadow]="'0 0 10px '+ color + ', 0 0 5px ' + color"></div>
          </div>
        </div>
        <div *ngIf="spinner" class="ng-spinner">
          <div class="ng-spinner-icon"
                [style.borderTopColor]="color"
                [style.borderLeftColor]="color"></div>
        </div>
      </div>
    </ng-container>
  `,
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                styles: ["ng-progress{z-index:999999;pointer-events:none}ng-progress[fixed=true] .ng-progress-bar,ng-progress[fixed=true] .ng-spinner{position:fixed}ng-progress[fixed=true] .ng-spinner{top:15px}ng-progress[fixed=true][spinnerPosition=left] .ng-spinner{left:15px}ng-progress[fixed=true][spinnerPosition=right] .ng-spinner{right:15px}ng-progress[thick=true] .ng-spinner-icon{width:24px;height:24px;border-width:3px}ng-progress[thick=true] .ng-bar-placeholder{height:3px!important}ng-progress[dir='ltr+'] .ng-meteor,ng-progress[dir=ltr-] .ng-meteor{-webkit-transform:rotate(3deg);transform:rotate(3deg)}ng-progress[dir='ltr+'][thick=true] .ng-meteor,ng-progress[dir=ltr-][thick=true] .ng-meteor{-webkit-transform:rotate(4deg);transform:rotate(4deg)}ng-progress[dir='ltr+'] .ng-bar,ng-progress[dir='rtl+'] .ng-bar{margin-left:-100%}ng-progress[dir='ltr+'] .ng-meteor,ng-progress[dir='rtl+'] .ng-meteor{right:0}ng-progress[dir='ltr+'] .ng-meteor,ng-progress[dir=rtl-] .ng-meteor{top:-3px}ng-progress[dir='ltr+'][thick=true] .ng-meteor,ng-progress[dir=rtl-][thick=true] .ng-meteor{top:-4px}ng-progress[dir='rtl+'] .ng-meteor,ng-progress[dir=ltr-] .ng-meteor{bottom:-3px}ng-progress[dir='rtl+'][thick=true] .ng-meteor,ng-progress[dir=ltr-][thick=true] .ng-meteor{bottom:-4px}ng-progress[dir='rtl+'] .ng-bar-placeholder,ng-progress[dir=ltr-] .ng-bar-placeholder{-webkit-transform:rotate(180deg);transform:rotate(180deg)}ng-progress[dir='rtl+'] .ng-spinner-icon,ng-progress[dir=ltr-] .ng-spinner-icon{animation-direction:reverse}ng-progress[dir='rtl+'] .ng-meteor,ng-progress[dir=rtl-] .ng-meteor{-webkit-transform:rotate(-3deg);transform:rotate(-3deg)}ng-progress[dir='rtl+'][thick=true] .ng-meteor,ng-progress[dir=rtl-][thick=true] .ng-meteor{-webkit-transform:rotate(-4deg);transform:rotate(-4deg)}ng-progress[spinnerPosition=left] .ng-spinner{left:10px}ng-progress[spinnerPosition=right] .ng-spinner{right:10px}.ng-progress-bar{position:relative;z-index:999999;top:0;left:0;width:100%;zoom:1;opacity:0}.ng-progress-bar.-active{opacity:1;transition:none}.ng-bar-placeholder{position:absolute;height:2px;width:100%}.ng-bar{width:100%;height:100%;-webkit-transform:translate(-100%,0,0);transform:translate(-100%,0,0)}.ng-meteor{display:block;position:absolute;width:100px;height:100%;opacity:1}.ng-spinner{position:absolute;display:block;z-index:1031;top:10px}.ng-spinner-icon{width:18px;height:18px;box-sizing:border-box;-webkit-animation:.4s linear infinite spinner-animation;animation:.4s linear infinite spinner-animation;border:2px solid transparent;border-radius:50%}@-webkit-keyframes spinner-animation{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes spinner-animation{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}"]
            }] }
];
/** @nocollapse */
NgProgressComponent.ctorParameters = () => [
    { type: NgProgress }
];
NgProgressComponent.propDecorators = {
    id: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    ease: [{ type: Input }],
    color: [{ type: Input }],
    speed: [{ type: Input }],
    thick: [{ type: Input }],
    fixed: [{ type: Input }],
    meteor: [{ type: Input }],
    spinner: [{ type: Input }],
    trickleSpeed: [{ type: Input }],
    debounceTime: [{ type: Input }],
    trickleFunc: [{ type: Input }],
    spinnerPosition: [{ type: Input }],
    direction: [{ type: Input }],
    started: [{ type: Output }],
    completed: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class NgProgressModule {
    /**
     * @param {?=} config
     * @return {?}
     */
    static forRoot(config) {
        return {
            ngModule: NgProgressModule,
            providers: [
                { provide: CONFIG, useValue: config }
            ]
        };
    }
}
NgProgressModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NgProgressComponent],
                exports: [NgProgressComponent],
                imports: [CommonModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { NgProgressModule, NgProgressComponent, NgProgressRef, NgProgress, CONFIG };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LXByb2dyZXNzYmFyLWNvcmUuanMubWFwIiwic291cmNlcyI6WyJuZzovL0BuZ3gtcHJvZ3Jlc3NiYXIvY29yZS9saWIvbmctcHJvZ3Jlc3MtcmVmLnRzIiwibmc6Ly9Abmd4LXByb2dyZXNzYmFyL2NvcmUvbGliL25nLXByb2dyZXNzLmludGVyZmFjZS50cyIsIm5nOi8vQG5neC1wcm9ncmVzc2Jhci9jb3JlL2xpYi9uZy1wcm9ncmVzcy5zZXJ2aWNlLnRzIiwibmc6Ly9Abmd4LXByb2dyZXNzYmFyL2NvcmUvbGliL25nLXByb2dyZXNzLmNvbXBvbmVudC50cyIsIm5nOi8vQG5neC1wcm9ncmVzc2Jhci9jb3JlL2xpYi9uZy1wcm9ncmVzcy5tb2R1bGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmdQcm9ncmVzc1N0YXRlLCBOZ1Byb2dyZXNzQ29uZmlnIH0gZnJvbSAnLi9uZy1wcm9ncmVzcy5pbnRlcmZhY2UnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0LCBCZWhhdmlvclN1YmplY3QsIHRpbWVyLCBvZiwgY29tYmluZUxhdGVzdCwgU3Vic2NyaXB0aW9uTGlrZSwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IHRhcCwgbWFwLCBza2lwLCBkZWxheSwgZmlsdGVyLCBkZWJvdW5jZSwgc3dpdGNoTWFwLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbmV4cG9ydCBjbGFzcyBOZ1Byb2dyZXNzUmVmIHtcclxuXHJcbiAgLyoqIFN0cmVhbSB0aGF0IGVtaXRzIHdoZW4gcHJvZ3Jlc3Mgc3RhdGUgaXMgY2hhbmdlZCAqL1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgX3N0YXRlOiBCZWhhdmlvclN1YmplY3Q8TmdQcm9ncmVzc1N0YXRlPjtcclxuICBzdGF0ZTogT2JzZXJ2YWJsZTxOZ1Byb2dyZXNzU3RhdGU+O1xyXG5cclxuICAvKiogU3RyZWFtIHRoYXQgZW1pdHMgd2hlbiBjb25maWcgaXMgY2hhbmdlZCAqL1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgX2NvbmZpZzogQmVoYXZpb3JTdWJqZWN0PE5nUHJvZ3Jlc3NDb25maWc+O1xyXG4gIGNvbmZpZzogT2JzZXJ2YWJsZTxOZ1Byb2dyZXNzU3RhdGU+O1xyXG5cclxuICAvKiogU3RyZWFtIHRoYXQgaW5jcmVtZW50cyBhbmQgdXBkYXRlcyBwcm9ncmVzcyBzdGF0ZSAqL1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgX3RyaWNrbGluZyA9IG5ldyBTdWJqZWN0KCk7XHJcblxyXG4gIC8qKiBTdHJlYW0gdGhhdCBjb21iaW5lcyBcIl90cmlja2xpbmdcIiBhbmQgXCJjb25maWdcIiBzdHJlYW1zICovXHJcbiAgcHJpdmF0ZSByZWFkb25seSBfd29ya2VyOiBTdWJzY3JpcHRpb25MaWtlID0gU3Vic2NyaXB0aW9uLkVNUFRZO1xyXG5cclxuICAvKiogR2V0IGN1cnJlbnQgcHJvZ3Jlc3Mgc3RhdGUgKi9cclxuICBwcml2YXRlIGdldCBjdXJyU3RhdGUoKTogTmdQcm9ncmVzc1N0YXRlIHtcclxuICAgIHJldHVybiB0aGlzLl9zdGF0ZS52YWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKiBDaGVjayBpZiBwcm9ncmVzcyBoYXMgc3RhcnRlZCAqL1xyXG4gIGdldCBpc1N0YXJ0ZWQoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5jdXJyU3RhdGUuYWN0aXZlO1xyXG4gIH1cclxuXHJcbiAgLyoqIFByb2dyZXNzIHN0YXJ0IGV2ZW50ICovXHJcbiAgZ2V0IHN0YXJ0ZWQoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XHJcbiAgICByZXR1cm4gdGhpcy5fc3RhdGUucGlwZShcclxuICAgICAgbWFwKChzdGF0ZTogTmdQcm9ncmVzc1N0YXRlKSA9PiBzdGF0ZS5hY3RpdmUpLFxyXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxyXG4gICAgICBmaWx0ZXIoYWN0aXZlID0+IGFjdGl2ZSlcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKiogUHJvZ3Jlc3MgZW5kZWQgZXZlbnQgKi9cclxuICBnZXQgY29tcGxldGVkKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlLnBpcGUoXHJcbiAgICAgIG1hcCgoc3RhdGU6IE5nUHJvZ3Jlc3NTdGF0ZSkgPT4gc3RhdGUuYWN0aXZlKSxcclxuICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcclxuICAgICAgZmlsdGVyKGFjdGl2ZSA9PiAhYWN0aXZlKSxcclxuICAgICAgc2tpcCgxKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yKGN1c3RvbUNvbmZpZzogTmdQcm9ncmVzc0NvbmZpZywgcHJpdmF0ZSBkZWxldGVJbnN0YW5jZTogRnVuY3Rpb24pIHtcclxuICAgIHRoaXMuX3N0YXRlID0gbmV3IEJlaGF2aW9yU3ViamVjdDxOZ1Byb2dyZXNzU3RhdGU+KHthY3RpdmU6IGZhbHNlLCB2YWx1ZTogMH0pO1xyXG4gICAgdGhpcy5fY29uZmlnID0gbmV3IEJlaGF2aW9yU3ViamVjdDxOZ1Byb2dyZXNzQ29uZmlnPihjdXN0b21Db25maWcpO1xyXG4gICAgdGhpcy5zdGF0ZSA9IHRoaXMuX3N0YXRlLmFzT2JzZXJ2YWJsZSgpO1xyXG4gICAgdGhpcy5jb25maWcgPSB0aGlzLl9zdGF0ZS5hc09ic2VydmFibGUoKTtcclxuXHJcbiAgICB0aGlzLl93b3JrZXIgPSBjb21iaW5lTGF0ZXN0KHRoaXMuX3RyaWNrbGluZywgdGhpcy5fY29uZmlnKS5waXBlKFxyXG4gICAgICBkZWJvdW5jZSgoW3N0YXJ0LCBjb25maWddOiBbYm9vbGVhbiwgTmdQcm9ncmVzc0NvbmZpZ10pID0+IHRpbWVyKHN0YXJ0ID8gY29uZmlnLmRlYm91bmNlVGltZSA6IDApKSxcclxuICAgICAgc3dpdGNoTWFwKChbc3RhcnQsIGNvbmZpZ106IFtib29sZWFuLCBOZ1Byb2dyZXNzQ29uZmlnXSkgPT4gc3RhcnQgPyB0aGlzLm9uVHJpY2tsaW5nKGNvbmZpZykgOiB0aGlzLm9uQ29tcGxldGUoY29uZmlnKSlcclxuICAgICkuc3Vic2NyaWJlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydCB0aGUgcHJvZ3Jlc3NcclxuICAgKi9cclxuICBzdGFydCgpIHtcclxuICAgIHRoaXMuX3RyaWNrbGluZy5uZXh0KHRydWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29tcGxldGUgdGhlIHByb2dyZXNzXHJcbiAgICovXHJcbiAgY29tcGxldGUoKSB7XHJcbiAgICB0aGlzLl90cmlja2xpbmcubmV4dChmYWxzZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbmNyZW1lbnQgdGhlIHByb2dyZXNzXHJcbiAgICogQHBhcmFtIGFtb3VudFxyXG4gICAqL1xyXG4gIGluYyhhbW91bnQ/OiBudW1iZXIpIHtcclxuICAgIGNvbnN0IG4gPSB0aGlzLmN1cnJTdGF0ZS52YWx1ZTtcclxuICAgIGlmICghdGhpcy5pc1N0YXJ0ZWQpIHtcclxuICAgICAgdGhpcy5zdGFydCgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHR5cGVvZiBhbW91bnQgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgYW1vdW50ID0gdGhpcy5fY29uZmlnLnZhbHVlLnRyaWNrbGVGdW5jKG4pO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuc2V0KG4gKyBhbW91bnQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHRoZSBwcm9ncmVzc1xyXG4gICAqIEBwYXJhbSBuXHJcbiAgICovXHJcbiAgc2V0KG46IG51bWJlcikge1xyXG4gICAgdGhpcy5zZXRTdGF0ZSh7dmFsdWU6IHRoaXMuY2xhbXAobiksIGFjdGl2ZTogdHJ1ZX0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IGNvbmZpZ1xyXG4gICAqIEBwYXJhbSBjb25maWdcclxuICAgKi9cclxuICBzZXRDb25maWcoY29uZmlnOiBOZ1Byb2dyZXNzQ29uZmlnKSB7XHJcbiAgICB0aGlzLl9jb25maWcubmV4dCh7Li4udGhpcy5fY29uZmlnLnZhbHVlLCAuLi5jb25maWd9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlc3Ryb3kgcHJvZ3Jlc3MgcmVmZXJlbmNlXHJcbiAgICovXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMuX3dvcmtlci51bnN1YnNjcmliZSgpO1xyXG4gICAgdGhpcy5fdHJpY2tsaW5nLmNvbXBsZXRlKCk7XHJcbiAgICB0aGlzLl9zdGF0ZS5jb21wbGV0ZSgpO1xyXG4gICAgdGhpcy5fY29uZmlnLmNvbXBsZXRlKCk7XHJcbiAgICB0aGlzLmRlbGV0ZUluc3RhbmNlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgcHJvZ3Jlc3Mgc3RhdGVcclxuICAgKiBAcGFyYW0gc3RhdGVcclxuICAgKi9cclxuICBwcml2YXRlIHNldFN0YXRlKHN0YXRlOiBOZ1Byb2dyZXNzU3RhdGUpIHtcclxuICAgIHRoaXMuX3N0YXRlLm5leHQoey4uLnRoaXMuY3VyclN0YXRlLCAuLi5zdGF0ZX0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2xhbXBzIGEgdmFsdWUgdG8gYmUgYmV0d2VlbiBtaW4gYW5kIG1heFxyXG4gICAqIEBwYXJhbSBuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBjbGFtcChuOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuX2NvbmZpZy52YWx1ZS5taW4sIE1hdGgubWluKHRoaXMuX2NvbmZpZy52YWx1ZS5tYXgsIG4pKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEtlZXBzIGluY3JlbWVudGluZyB0aGUgcHJvZ3Jlc3NcclxuICAgKiBAcGFyYW0gY29uZmlnXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBvblRyaWNrbGluZyhjb25maWc6IE5nUHJvZ3Jlc3NDb25maWcpOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xyXG4gICAgaWYgKCF0aGlzLmlzU3RhcnRlZCkge1xyXG4gICAgICB0aGlzLnNldCh0aGlzLl9jb25maWcudmFsdWUubWluKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aW1lcigwLCBjb25maWcudHJpY2tsZVNwZWVkKS5waXBlKHRhcCgoKSA9PiB0aGlzLmluYygpKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb21wbGV0ZXMgdGhlbiByZXNldHMgdGhlIHByb2dyZXNzXHJcbiAgICogQHBhcmFtIGNvbmZpZ1xyXG4gICAqL1xyXG4gIHByaXZhdGUgb25Db21wbGV0ZShjb25maWc6IE5nUHJvZ3Jlc3NDb25maWcpOiBPYnNlcnZhYmxlPGFueT4ge1xyXG4gICAgcmV0dXJuICF0aGlzLmlzU3RhcnRlZCA/IG9mKHt9KSA6IG9mKHt9KS5waXBlKFxyXG4gICAgICAvLyBDb21wbGV0ZXMgdGhlIHByb2dyZXNzXHJcbiAgICAgIHRhcCgoKSA9PiB0aGlzLnNldFN0YXRlKHt2YWx1ZTogMTAwfSkpLFxyXG5cclxuICAgICAgLy8gSGlkZXMgdGhlIHByb2dyZXNzIGJhciBhZnRlciBhIHRpbnkgZGVsYXlcclxuICAgICAgZGVsYXkoY29uZmlnLnNwZWVkICogMS43KSxcclxuICAgICAgdGFwKCgpID0+IHRoaXMuc2V0U3RhdGUoe2FjdGl2ZTogZmFsc2V9KSksXHJcblxyXG4gICAgICAvLyBSZXNldHMgdGhlIHByb2dyZXNzIHN0YXRlXHJcbiAgICAgIGRlbGF5KGNvbmZpZy5zcGVlZCksXHJcbiAgICAgIHRhcCgoKSA9PiB0aGlzLnNldFN0YXRlKHt2YWx1ZTogMH0pKVxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgSW5qZWN0aW9uVG9rZW4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTmdQcm9ncmVzc1N0YXRlIHtcclxuICBhY3RpdmU/OiBib29sZWFuO1xyXG4gIHZhbHVlPzogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE5nUHJvZ3Jlc3NDb25maWcge1xyXG4gIHNwaW5uZXJQb3NpdGlvbj86ICdsZWZ0JyB8ICdyaWdodCc7XHJcbiAgZGlyZWN0aW9uPzogJ2x0cisnIHwgJ2x0ci0nIHwgJ3J0bCsnIHwgJ3J0bC0nO1xyXG4gIGVhc2U/OiBzdHJpbmc7XHJcbiAgY29sb3I/OiBzdHJpbmc7XHJcbiAgdGhpY2s/OiBib29sZWFuO1xyXG4gIGZpeGVkPzogYm9vbGVhbjtcclxuICBtZXRlb3I/OiBib29sZWFuO1xyXG4gIHNwaW5uZXI/OiBib29sZWFuO1xyXG4gIG1heD86IG51bWJlcjtcclxuICBtaW4/OiBudW1iZXI7XHJcbiAgc3BlZWQ/OiBudW1iZXI7XHJcbiAgdHJpY2tsZVNwZWVkPzogbnVtYmVyO1xyXG4gIHRyaWNrbGVGdW5jPzogKG46IG51bWJlcikgPT4gbnVtYmVyO1xyXG4gIGRlYm91bmNlVGltZT86IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IENPTkZJRyA9IG5ldyBJbmplY3Rpb25Ub2tlbjxOZ1Byb2dyZXNzQ29uZmlnPignY29uZmlnJyk7XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdCwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgTmdQcm9ncmVzc1JlZiB9IGZyb20gJy4vbmctcHJvZ3Jlc3MtcmVmJztcclxuaW1wb3J0IHsgTmdQcm9ncmVzc0NvbmZpZywgQ09ORklHIH0gZnJvbSAnLi9uZy1wcm9ncmVzcy5pbnRlcmZhY2UnO1xyXG5cclxuY29uc3QgZGVmYXVsdENvbmZpZzogTmdQcm9ncmVzc0NvbmZpZyA9IHtcclxuICBtaW46IDgsXHJcbiAgbWF4OiAxMDAsXHJcbiAgc3BlZWQ6IDIwMCxcclxuICBkZWJvdW5jZVRpbWU6IDAsXHJcbiAgdHJpY2tsZVNwZWVkOiAzMDAsXHJcbiAgZml4ZWQ6IHRydWUsXHJcbiAgbWV0ZW9yOiB0cnVlLFxyXG4gIHRoaWNrOiBmYWxzZSxcclxuICBzcGlubmVyOiB0cnVlLFxyXG4gIGVhc2U6ICdsaW5lYXInLFxyXG4gIGNvbG9yOiAnIzFCOTVFMCcsXHJcbiAgZGlyZWN0aW9uOiAnbHRyKycsXHJcbiAgc3Bpbm5lclBvc2l0aW9uOiAncmlnaHQnLFxyXG4gIHRyaWNrbGVGdW5jOiAobjogbnVtYmVyKTogbnVtYmVyID0+IHtcclxuICAgIGlmIChuID49IDAgJiYgbiA8IDIwKSByZXR1cm4gMTA7XHJcbiAgICBpZiAobiA+PSAyMCAmJiBuIDwgNTApIHJldHVybiA0O1xyXG4gICAgaWYgKG4gPj0gNTAgJiYgbiA8IDgwKSByZXR1cm4gMjtcclxuICAgIGlmIChuID49IDgwICYmIG4gPCA5OSkgcmV0dXJuIDAuNTtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxufTtcclxuXHJcbkBJbmplY3RhYmxlKHtcclxuICBwcm92aWRlZEluOiAncm9vdCdcclxufSlcclxuZXhwb3J0IGNsYXNzIE5nUHJvZ3Jlc3Mge1xyXG5cclxuICAvKiogU3RvcmUgcHJvZ3Jlc3MgYmFyIGluc3RhbmNlcyAqL1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgX2luc3RhbmNlcyA9IG5ldyBNYXA8c3RyaW5nLCBOZ1Byb2dyZXNzUmVmPigpO1xyXG5cclxuICAvKiogR2xvYmFsIGNvbmZpZyAqL1xyXG4gIGNvbmZpZzogTmdQcm9ncmVzc0NvbmZpZztcclxuXHJcbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgQEluamVjdChDT05GSUcpIGNvbmZpZzogTmdQcm9ncmVzc0NvbmZpZykge1xyXG4gICAgdGhpcy5jb25maWcgPSB7Li4uZGVmYXVsdENvbmZpZywgLi4uY29uZmlnfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBvciBDcmVhdGUgcHJvZ3Jlc3MgYmFyIGJ5IElEXHJcbiAgICogQHBhcmFtIGlkXHJcbiAgICogQHBhcmFtIGNvbmZpZ1xyXG4gICAqL1xyXG4gIHJlZihpZCA9ICdyb290JywgY29uZmlnPzogTmdQcm9ncmVzc0NvbmZpZykge1xyXG4gICAgaWYgKHRoaXMuX2luc3RhbmNlcy5oYXMoaWQpKSB7XHJcbiAgICAgIC8vIEdldCBQcm9ncmVzc1JlZiBpbnN0YW5jZVxyXG4gICAgICBjb25zdCBwcm9ncmVzc1JlZiA9IHRoaXMuX2luc3RhbmNlcy5nZXQoaWQpO1xyXG4gICAgICBpZiAoY29uZmlnKSB7XHJcbiAgICAgICAgcHJvZ3Jlc3NSZWYuc2V0Q29uZmlnKHsuLi50aGlzLmNvbmZpZywgLi4uY29uZmlnfSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHByb2dyZXNzUmVmO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gQ3JlYXRlIG5ldyBQcm9ncmVzc1JlZiBpbnN0YW5jZVxyXG4gICAgICBjb25zdCBwcm9ncmVzc1JlZiA9IG5ldyBOZ1Byb2dyZXNzUmVmKHsuLi50aGlzLmNvbmZpZywgLi4uY29uZmlnfSwgdGhpcy5kZWxldGVJbnN0YW5jZShpZCkpO1xyXG4gICAgICByZXR1cm4gdGhpcy5faW5zdGFuY2VzLnNldChpZCwgcHJvZ3Jlc3NSZWYpLmdldChpZCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXN0cm95IGFsbCBwcm9ncmVzcyBiYXIgaW5zdGFuY2VzXHJcbiAgICovXHJcbiAgZGVzdHJveUFsbCgpIHtcclxuICAgIHRoaXMuX2luc3RhbmNlcy5mb3JFYWNoKChyZWY6IE5nUHJvZ3Jlc3NSZWYpID0+IHJlZi5kZXN0cm95KCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQSBkZXN0cm95ZXIgZnVuY3Rpb24gZm9yIGVhY2ggcHJvZ3Jlc3MgYmFyIGluc3RhbmNlXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBkZWxldGVJbnN0YW5jZShpZDogc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICB0aGlzLl9pbnN0YW5jZXMuZGVsZXRlKGlkKTtcclxuICAgIH07XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7XHJcbiAgQ29tcG9uZW50LFxyXG4gIElucHV0LFxyXG4gIE9uQ2hhbmdlcyxcclxuICBPbkRlc3Ryb3ksXHJcbiAgT25Jbml0LFxyXG4gIE91dHB1dCxcclxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcclxuICBFdmVudEVtaXR0ZXIsXHJcbiAgVmlld0VuY2Fwc3VsYXRpb25cclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3Vic2NyaXB0aW9uLCBTdWJzY3JpcHRpb25MaWtlfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBOZ1Byb2dyZXNzIH0gZnJvbSAnLi9uZy1wcm9ncmVzcy5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTmdQcm9ncmVzc1JlZiB9IGZyb20gJy4vbmctcHJvZ3Jlc3MtcmVmJztcclxuaW1wb3J0IHsgTmdQcm9ncmVzc1N0YXRlIH0gZnJvbSAnLi9uZy1wcm9ncmVzcy5pbnRlcmZhY2UnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICduZy1wcm9ncmVzcycsXHJcbiAgaG9zdDoge1xyXG4gICAgJ3JvbGUnOiAncHJvZ3Jlc3NiYXInLFxyXG4gICAgJ1thdHRyLnNwaW5uZXJQb3NpdGlvbl0nOiAnc3Bpbm5lclBvc2l0aW9uJyxcclxuICAgICdbYXR0ci5kaXJdJzogJ2RpcmVjdGlvbicsXHJcbiAgICAnW2F0dHIudGhpY2tdJzogJ3RoaWNrJyxcclxuICAgICdbYXR0ci5maXhlZF0nOiAnZml4ZWQnXHJcbiAgfSxcclxuICB0ZW1wbGF0ZTogYFxyXG4gICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cInN0YXRlJCB8IGFzeW5jOyBsZXQgc3RhdGVcIj5cclxuICAgICAgPGRpdiBjbGFzcz1cIm5nLXByb2dyZXNzLWJhclwiXHJcbiAgICAgICAgICAgIFtjbGFzcy4tYWN0aXZlXT1cInN0YXRlLmFjdGl2ZVwiXHJcbiAgICAgICAgICAgIFtzdHlsZS50cmFuc2l0aW9uXT1cIidvcGFjaXR5ICcgKyBzcGVlZCArICdtcyAnICsgZWFzZVwiPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJuZy1iYXItcGxhY2Vob2xkZXJcIj5cclxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJuZy1iYXJcIlxyXG4gICAgICAgICAgICAgICAgW3N0eWxlLnRyYW5zZm9ybV09XCJzdGF0ZS50cmFuc2Zvcm1cIlxyXG4gICAgICAgICAgICAgICAgW3N0eWxlLmJhY2tncm91bmRDb2xvcl09XCJjb2xvclwiXHJcbiAgICAgICAgICAgICAgICBbc3R5bGUudHJhbnNpdGlvbl09XCJzdGF0ZS5hY3RpdmUgPyAnYWxsICcgKyBzcGVlZCArICdtcyAnICsgZWFzZSA6ICdub25lJ1wiPlxyXG4gICAgICAgICAgICA8ZGl2ICpuZ0lmPVwibWV0ZW9yXCIgY2xhc3M9XCJuZy1tZXRlb3JcIiBbc3R5bGUuYm94U2hhZG93XT1cIicwIDAgMTBweCAnKyBjb2xvciArICcsIDAgMCA1cHggJyArIGNvbG9yXCI+PC9kaXY+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2ICpuZ0lmPVwic3Bpbm5lclwiIGNsYXNzPVwibmctc3Bpbm5lclwiPlxyXG4gICAgICAgICAgPGRpdiBjbGFzcz1cIm5nLXNwaW5uZXItaWNvblwiXHJcbiAgICAgICAgICAgICAgICBbc3R5bGUuYm9yZGVyVG9wQ29sb3JdPVwiY29sb3JcIlxyXG4gICAgICAgICAgICAgICAgW3N0eWxlLmJvcmRlckxlZnRDb2xvcl09XCJjb2xvclwiPjwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvbmctY29udGFpbmVyPlxyXG4gIGAsXHJcbiAgc3R5bGVVcmxzOiBbJy4vbmctcHJvZ3Jlc3MuY29tcG9uZW50LnNjc3MnXSxcclxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxyXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG4gIHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhbHNlXHJcbn0pXHJcblxyXG5leHBvcnQgY2xhc3MgTmdQcm9ncmVzc0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xyXG5cclxuICBwcml2YXRlIF9zdGFydGVkOiBTdWJzY3JpcHRpb25MaWtlID0gU3Vic2NyaXB0aW9uLkVNUFRZO1xyXG4gIHByaXZhdGUgX2NvbXBsZXRlZDogU3Vic2NyaXB0aW9uTGlrZSA9IFN1YnNjcmlwdGlvbi5FTVBUWTtcclxuXHJcbiAgLyoqIFByb2dyZXNzIGJhciB3b3JrZXIgKi9cclxuICBwcm9ncmVzc1JlZjogTmdQcm9ncmVzc1JlZjtcclxuXHJcbiAgLyoqIFN0cmVhbSB0aGF0IGVtaXRzIHByb2dyZXNzIHN0YXRlICovXHJcbiAgc3RhdGUkOiBPYnNlcnZhYmxlPHsgYWN0aXZlOiBib29sZWFuLCB0cmFuc2Zvcm06IHN0cmluZyB9PjtcclxuXHJcbiAgLyoqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2UgaWYgaWQgaXMgbm90IGFscmVhZHkgZXhpc3RzICovXHJcbiAgQElucHV0KCkgaWQgPSAncm9vdCc7XHJcblxyXG4gIC8qKiBJbml0aWFsaXplcyBpbnB1dHMgZnJvbSB0aGUgZ2xvYmFsIGNvbmZpZyAqL1xyXG4gIEBJbnB1dCgpIG1pbjogbnVtYmVyID0gdGhpcy5fbmdQcm9ncmVzcy5jb25maWcubWluO1xyXG4gIEBJbnB1dCgpIG1heDogbnVtYmVyID0gdGhpcy5fbmdQcm9ncmVzcy5jb25maWcubWF4O1xyXG4gIEBJbnB1dCgpIGVhc2U6IHN0cmluZyA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLmVhc2U7XHJcbiAgQElucHV0KCkgY29sb3I6IHN0cmluZyA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLmNvbG9yO1xyXG4gIEBJbnB1dCgpIHNwZWVkOiBudW1iZXIgPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy5zcGVlZDtcclxuICBASW5wdXQoKSB0aGljazogYm9vbGVhbiA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLnRoaWNrO1xyXG4gIEBJbnB1dCgpIGZpeGVkOiBib29sZWFuID0gdGhpcy5fbmdQcm9ncmVzcy5jb25maWcuZml4ZWQ7XHJcbiAgQElucHV0KCkgbWV0ZW9yOiBib29sZWFuID0gdGhpcy5fbmdQcm9ncmVzcy5jb25maWcubWV0ZW9yO1xyXG4gIEBJbnB1dCgpIHNwaW5uZXI6IGJvb2xlYW4gPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy5zcGlubmVyO1xyXG4gIEBJbnB1dCgpIHRyaWNrbGVTcGVlZDogbnVtYmVyID0gdGhpcy5fbmdQcm9ncmVzcy5jb25maWcudHJpY2tsZVNwZWVkO1xyXG4gIEBJbnB1dCgpIGRlYm91bmNlVGltZTogbnVtYmVyID0gdGhpcy5fbmdQcm9ncmVzcy5jb25maWcuZGVib3VuY2VUaW1lO1xyXG4gIEBJbnB1dCgpIHRyaWNrbGVGdW5jOiAobjogbnVtYmVyKSA9PiBudW1iZXIgPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy50cmlja2xlRnVuYztcclxuICBASW5wdXQoKSBzcGlubmVyUG9zaXRpb246ICdsZWZ0JyB8ICdyaWdodCcgPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy5zcGlubmVyUG9zaXRpb247XHJcbiAgQElucHV0KCkgZGlyZWN0aW9uOiAnbHRyKycgfCAnbHRyLScgfCAncnRsKycgfCAncnRsLScgPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy5kaXJlY3Rpb247XHJcbiAgQE91dHB1dCgpIHN0YXJ0ZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgQE91dHB1dCgpIGNvbXBsZXRlZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuXHJcbiAgZ2V0IGlzU3RhcnRlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLnByb2dyZXNzUmVmLmlzU3RhcnRlZDtcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX25nUHJvZ3Jlc3M6IE5nUHJvZ3Jlc3MpIHtcclxuICB9XHJcblxyXG4gIG5nT25DaGFuZ2VzKCkge1xyXG4gICAgaWYgKHRoaXMucHJvZ3Jlc3NSZWYgaW5zdGFuY2VvZiBOZ1Byb2dyZXNzUmVmKSB7XHJcbiAgICAgIC8vIFVwZGF0ZSBwcm9ncmVzcyBiYXIgY29uZmlnIHdoZW4gaW5wdXRzIGNoYW5nZVxyXG4gICAgICB0aGlzLnByb2dyZXNzUmVmLnNldENvbmZpZyh7XHJcbiAgICAgICAgbWF4OiAodGhpcy5tYXggPiAwICYmIHRoaXMubWF4IDw9IDEwMCkgPyB0aGlzLm1heCA6IDEwMCxcclxuICAgICAgICBtaW46ICh0aGlzLm1pbiA8IDEwMCAmJiB0aGlzLm1pbiA+PSAwKSA/IHRoaXMubWluIDogMCxcclxuICAgICAgICBzcGVlZDogdGhpcy5zcGVlZCxcclxuICAgICAgICB0cmlja2xlU3BlZWQ6IHRoaXMudHJpY2tsZVNwZWVkLFxyXG4gICAgICAgIHRyaWNrbGVGdW5jOiB0aGlzLnRyaWNrbGVGdW5jLFxyXG4gICAgICAgIGRlYm91bmNlVGltZTogdGhpcy5kZWJvdW5jZVRpbWVcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBuZ09uSW5pdCgpIHtcclxuICAgIC8vIEdldCBwcm9ncmVzcyBiYXIgc2VydmljZSBpbnN0YW5jZVxyXG4gICAgdGhpcy5wcm9ncmVzc1JlZiA9IHRoaXMuX25nUHJvZ3Jlc3MucmVmKHRoaXMuaWQsIHtcclxuICAgICAgbWF4OiB0aGlzLm1heCxcclxuICAgICAgbWluOiB0aGlzLm1pbixcclxuICAgICAgc3BlZWQ6IHRoaXMuc3BlZWQsXHJcbiAgICAgIHRyaWNrbGVTcGVlZDogdGhpcy50cmlja2xlU3BlZWQsXHJcbiAgICAgIGRlYm91bmNlVGltZTogdGhpcy5kZWJvdW5jZVRpbWVcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFN1YnNjcmliZSB0byBwcm9ncmVzcyBzdGF0ZVxyXG4gICAgdGhpcy5zdGF0ZSQgPSB0aGlzLnByb2dyZXNzUmVmLnN0YXRlLnBpcGUoXHJcbiAgICAgIG1hcCgoc3RhdGU6IE5nUHJvZ3Jlc3NTdGF0ZSkgPT4gKHtcclxuICAgICAgICBhY3RpdmU6IHN0YXRlLmFjdGl2ZSxcclxuICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke3N0YXRlLnZhbHVlfSUsMCwwKWBcclxuICAgICAgfSkpXHJcbiAgICApO1xyXG5cclxuICAgIC8vIFN1YnNjcmliZXMgdG8gc3RhcnRlZCBhbmQgY29tcGxldGVkIGV2ZW50cyBvbiBkZW1hblxyXG4gICAgaWYgKHRoaXMuc3RhcnRlZC5vYnNlcnZlcnMubGVuZ3RoKSB7XHJcbiAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0aGlzLnByb2dyZXNzUmVmLnN0YXJ0ZWQuc3Vic2NyaWJlKCgpID0+IHRoaXMuc3RhcnRlZC5lbWl0KCkpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuY29tcGxldGVkLm9ic2VydmVycy5sZW5ndGgpIHtcclxuICAgICAgdGhpcy5fY29tcGxldGVkID0gdGhpcy5wcm9ncmVzc1JlZi5jb21wbGV0ZWQuc3Vic2NyaWJlKCgpID0+IHRoaXMuY29tcGxldGVkLmVtaXQoKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBuZ09uRGVzdHJveSgpIHtcclxuICAgIHRoaXMuX3N0YXJ0ZWQudW5zdWJzY3JpYmUoKTtcclxuICAgIHRoaXMuX2NvbXBsZXRlZC51bnN1YnNjcmliZSgpO1xyXG4gICAgdGhpcy5wcm9ncmVzc1JlZi5kZXN0cm95KCk7XHJcbiAgfVxyXG5cclxuICBzdGFydCgpIHtcclxuICAgIHRoaXMucHJvZ3Jlc3NSZWYuc3RhcnQoKTtcclxuICB9XHJcblxyXG4gIGNvbXBsZXRlKCkge1xyXG4gICAgdGhpcy5wcm9ncmVzc1JlZi5jb21wbGV0ZSgpO1xyXG4gIH1cclxuXHJcbiAgaW5jKG4/OiBudW1iZXIpIHtcclxuICAgIHRoaXMucHJvZ3Jlc3NSZWYuaW5jKG4pO1xyXG4gIH1cclxuXHJcbiAgc2V0KG46IG51bWJlcikge1xyXG4gICAgdGhpcy5wcm9ncmVzc1JlZi5zZXQobik7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IE1vZHVsZVdpdGhQcm92aWRlcnMsIE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7IE5nUHJvZ3Jlc3NDb21wb25lbnQgfSBmcm9tICcuL25nLXByb2dyZXNzLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IE5nUHJvZ3Jlc3NDb25maWcsIENPTkZJRyB9IGZyb20gJy4vbmctcHJvZ3Jlc3MuaW50ZXJmYWNlJztcclxuXHJcbkBOZ01vZHVsZSh7XHJcbiAgZGVjbGFyYXRpb25zOiBbTmdQcm9ncmVzc0NvbXBvbmVudF0sXHJcbiAgZXhwb3J0czogW05nUHJvZ3Jlc3NDb21wb25lbnRdLFxyXG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBOZ1Byb2dyZXNzTW9kdWxlIHtcclxuICBzdGF0aWMgZm9yUm9vdChjb25maWc/OiBOZ1Byb2dyZXNzQ29uZmlnKTogTW9kdWxlV2l0aFByb3ZpZGVycyB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBuZ01vZHVsZTogTmdQcm9ncmVzc01vZHVsZSxcclxuICAgICAgcHJvdmlkZXJzOiBbXHJcbiAgICAgICAge3Byb3ZpZGU6IENPTkZJRywgdXNlVmFsdWU6IGNvbmZpZ31cclxuICAgICAgXVxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUNBLE1BR2EsYUFBYTs7Ozs7SUE2Q3hCLFlBQVksWUFBOEIsRUFBVSxjQUF3QjtRQUF4QixtQkFBYyxHQUFkLGNBQWMsQ0FBVTs7OzswQkFsQzlDLElBQUksT0FBTyxFQUFFOzs7O3VCQUdFLFlBQVksQ0FBQyxLQUFLO1FBZ0M3RCxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksZUFBZSxDQUFrQixFQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBQyxDQUFDLENBQUM7UUFDOUUsSUFBSSxDQUFDLE9B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