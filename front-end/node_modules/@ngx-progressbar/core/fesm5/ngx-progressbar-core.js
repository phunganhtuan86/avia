import { __read, __assign } from 'tslib';
import { Subject, BehaviorSubject, timer, of, combineLatest, Subscription } from 'rxjs';
import { tap, map, skip, delay, filter, debounce, switchMap, distinctUntilChanged } from 'rxjs/operators';
import { InjectionToken, Injectable, Inject, Optional, NgModule, Component, Input, Output, ChangeDetectionStrategy, EventEmitter, ViewEncapsulation, defineInjectable, inject } from '@angular/core';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var NgProgressRef = /** @class */ (function () {
    function NgProgressRef(customConfig, deleteInstance) {
        var _this = this;
        this.deleteInstance = deleteInstance;
        /**
         * Stream that increments and updates progress state
         */
        this._trickling = new Subject();
        /**
         * Stream that combines "_trickling" and "config" streams
         */
        this._worker = Subscription.EMPTY;
        this._state = new BehaviorSubject({ active: false, value: 0 });
        this._config = new BehaviorSubject(customConfig);
        this.state = this._state.asObservable();
        this.config = this._state.asObservable();
        this._worker = combineLatest(this._trickling, this._config).pipe(debounce(function (_a) {
            var _b = __read(_a, 2), start = _b[0], config = _b[1];
            return timer(start ? config.debounceTime : 0);
        }), switchMap(function (_a) {
            var _b = __read(_a, 2), start = _b[0], config = _b[1];
            return start ? _this.onTrickling(config) : _this.onComplete(config);
        })).subscribe();
    }
    Object.defineProperty(NgProgressRef.prototype, "currState", {
        get: /**
         * Get current progress state
         * @return {?}
         */
        function () {
            return this._state.value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgProgressRef.prototype, "isStarted", {
        /** Check if progress has started */
        get: /**
         * Check if progress has started
         * @return {?}
         */
        function () {
            return this.currState.active;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgProgressRef.prototype, "started", {
        /** Progress start event */
        get: /**
         * Progress start event
         * @return {?}
         */
        function () {
            return this._state.pipe(map(function (state) { return state.active; }), distinctUntilChanged(), filter(function (active) { return active; }));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgProgressRef.prototype, "completed", {
        /** Progress ended event */
        get: /**
         * Progress ended event
         * @return {?}
         */
        function () {
            return this._state.pipe(map(function (state) { return state.active; }), distinctUntilChanged(), filter(function (active) { return !active; }), skip(1));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Start the progress
     */
    /**
     * Start the progress
     * @return {?}
     */
    NgProgressRef.prototype.start = /**
     * Start the progress
     * @return {?}
     */
    function () {
        this._trickling.next(true);
    };
    /**
     * Complete the progress
     */
    /**
     * Complete the progress
     * @return {?}
     */
    NgProgressRef.prototype.complete = /**
     * Complete the progress
     * @return {?}
     */
    function () {
        this._trickling.next(false);
    };
    /**
     * Increment the progress
     * @param amount
     */
    /**
     * Increment the progress
     * @param {?=} amount
     * @return {?}
     */
    NgProgressRef.prototype.inc = /**
     * Increment the progress
     * @param {?=} amount
     * @return {?}
     */
    function (amount) {
        /** @type {?} */
        var n = this.currState.value;
        if (!this.isStarted) {
            this.start();
        }
        else {
            if (typeof amount !== 'number') {
                amount = this._config.value.trickleFunc(n);
            }
            this.set(n + amount);
        }
    };
    /**
     * Set the progress
     * @param n
     */
    /**
     * Set the progress
     * @param {?} n
     * @return {?}
     */
    NgProgressRef.prototype.set = /**
     * Set the progress
     * @param {?} n
     * @return {?}
     */
    function (n) {
        this.setState({ value: this.clamp(n), active: true });
    };
    /**
     * Set config
     * @param config
     */
    /**
     * Set config
     * @param {?} config
     * @return {?}
     */
    NgProgressRef.prototype.setConfig = /**
     * Set config
     * @param {?} config
     * @return {?}
     */
    function (config) {
        this._config.next(__assign({}, this._config.value, config));
    };
    /**
     * Destroy progress reference
     */
    /**
     * Destroy progress reference
     * @return {?}
     */
    NgProgressRef.prototype.destroy = /**
     * Destroy progress reference
     * @return {?}
     */
    function () {
        this._worker.unsubscribe();
        this._trickling.complete();
        this._state.complete();
        this._config.complete();
        this.deleteInstance();
    };
    /**
     * Set progress state
     * @param {?} state
     * @return {?}
     */
    NgProgressRef.prototype.setState = /**
     * Set progress state
     * @param {?} state
     * @return {?}
     */
    function (state) {
        this._state.next(__assign({}, this.currState, state));
    };
    /**
     * Clamps a value to be between min and max
     * @param {?} n
     * @return {?}
     */
    NgProgressRef.prototype.clamp = /**
     * Clamps a value to be between min and max
     * @param {?} n
     * @return {?}
     */
    function (n) {
        return Math.max(this._config.value.min, Math.min(this._config.value.max, n));
    };
    /**
     * Keeps incrementing the progress
     * @param {?} config
     * @return {?}
     */
    NgProgressRef.prototype.onTrickling = /**
     * Keeps incrementing the progress
     * @param {?} config
     * @return {?}
     */
    function (config) {
        var _this = this;
        if (!this.isStarted) {
            this.set(this._config.value.min);
        }
        return timer(0, config.trickleSpeed).pipe(tap(function () { return _this.inc(); }));
    };
    /**
     * Completes then resets the progress
     * @param {?} config
     * @return {?}
     */
    NgProgressRef.prototype.onComplete = /**
     * Completes then resets the progress
     * @param {?} config
     * @return {?}
     */
    function (config) {
        var _this = this;
        return !this.isStarted ? of({}) : of({}).pipe(
        // Completes the progress
        tap(function () { return _this.setState({ value: 100 }); }), 
        // Hides the progress bar after a tiny delay
        delay(config.speed * 1.7), tap(function () { return _this.setState({ active: false }); }), 
        // Resets the progress state
        delay(config.speed), tap(function () { return _this.setState({ value: 0 }); }));
    };
    return NgProgressRef;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var CONFIG = new InjectionToken('config');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ɵ0 = function (n) {
    if (n >= 0 && n < 20)
        return 10;
    if (n >= 20 && n < 50)
        return 4;
    if (n >= 50 && n < 80)
        return 2;
    if (n >= 80 && n < 99)
        return 0.5;
    return 0;
};
/** @type {?} */
var defaultConfig = {
    min: 8,
    max: 100,
    speed: 200,
    debounceTime: 0,
    trickleSpeed: 300,
    fixed: true,
    meteor: true,
    thick: false,
    spinner: true,
    ease: 'linear',
    color: '#1B95E0',
    direction: 'ltr+',
    spinnerPosition: 'right',
    trickleFunc: ɵ0
};
var NgProgress = /** @class */ (function () {
    function NgProgress(config) {
        /**
         * Store progress bar instances
         */
        this._instances = new Map();
        this.config = __assign({}, defaultConfig, config);
    }
    /**
     * Get or Create progress bar by ID
     * @param id
     * @param config
     */
    /**
     * Get or Create progress bar by ID
     * @param {?=} id
     * @param {?=} config
     * @return {?}
     */
    NgProgress.prototype.ref = /**
     * Get or Create progress bar by ID
     * @param {?=} id
     * @param {?=} config
     * @return {?}
     */
    function (id, config) {
        if (id === void 0) { id = 'root'; }
        if (this._instances.has(id)) {
            /** @type {?} */
            var progressRef = this._instances.get(id);
            if (config) {
                progressRef.setConfig(__assign({}, this.config, config));
            }
            return progressRef;
        }
        else {
            /** @type {?} */
            var progressRef = new NgProgressRef(__assign({}, this.config, config), this.deleteInstance(id));
            return this._instances.set(id, progressRef).get(id);
        }
    };
    /**
     * Destroy all progress bar instances
     */
    /**
     * Destroy all progress bar instances
     * @return {?}
     */
    NgProgress.prototype.destroyAll = /**
     * Destroy all progress bar instances
     * @return {?}
     */
    function () {
        this._instances.forEach(function (ref) { return ref.destroy(); });
    };
    /**
     * A destroyer function for each progress bar instance
     * @param {?} id
     * @return {?}
     */
    NgProgress.prototype.deleteInstance = /**
     * A destroyer function for each progress bar instance
     * @param {?} id
     * @return {?}
     */
    function (id) {
        var _this = this;
        return function () {
            _this._instances.delete(id);
        };
    };
    NgProgress.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    NgProgress.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CONFIG,] }] }
    ]; };
    /** @nocollapse */ NgProgress.ngInjectableDef = defineInjectable({ factory: function NgProgress_Factory() { return new NgProgress(inject(CONFIG, 8)); }, token: NgProgress, providedIn: "root" });
    return NgProgress;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var NgProgressComponent = /** @class */ (function () {
    function NgProgressComponent(_ngProgress) {
        this._ngProgress = _ngProgress;
        this._started = Subscription.EMPTY;
        this._completed = Subscription.EMPTY;
        /**
         * Creates a new instance if id is not already exists
         */
        this.id = 'root';
        /**
         * Initializes inputs from the global config
         */
        this.min = this._ngProgress.config.min;
        this.max = this._ngProgress.config.max;
        this.ease = this._ngProgress.config.ease;
        this.color = this._ngProgress.config.color;
        this.speed = this._ngProgress.config.speed;
        this.thick = this._ngProgress.config.thick;
        this.fixed = this._ngProgress.config.fixed;
        this.meteor = this._ngProgress.config.meteor;
        this.spinner = this._ngProgress.config.spinner;
        this.trickleSpeed = this._ngProgress.config.trickleSpeed;
        this.debounceTime = this._ngProgress.config.debounceTime;
        this.trickleFunc = this._ngProgress.config.trickleFunc;
        this.spinnerPosition = this._ngProgress.config.spinnerPosition;
        this.direction = this._ngProgress.config.direction;
        this.started = new EventEmitter();
        this.completed = new EventEmitter();
    }
    Object.defineProperty(NgProgressComponent.prototype, "isStarted", {
        get: /**
         * @return {?}
         */
        function () {
            return this.progressRef.isStarted;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NgProgressComponent.prototype.ngOnChanges = /**
     * @return {?}
     */
    function () {
        if (this.progressRef instanceof NgProgressRef) {
            // Update progress bar config when inputs change
            this.progressRef.setConfig({
                max: (this.max > 0 && this.max <= 100) ? this.max : 100,
                min: (this.min < 100 && this.min >= 0) ? this.min : 0,
                speed: this.speed,
                trickleSpeed: this.trickleSpeed,
                trickleFunc: this.trickleFunc,
                debounceTime: this.debounceTime
            });
        }
    };
    /**
     * @return {?}
     */
    NgProgressComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Get progress bar service instance
        this.progressRef = this._ngProgress.ref(this.id, {
            max: this.max,
            min: this.min,
            speed: this.speed,
            trickleSpeed: this.trickleSpeed,
            debounceTime: this.debounceTime
        });
        // Subscribe to progress state
        this.state$ = this.progressRef.state.pipe(map(function (state) { return ({
            active: state.active,
            transform: "translate3d(" + state.value + "%,0,0)"
        }); }));
        // Subscribes to started and completed events on deman
        if (this.started.observers.length) {
            this._started = this.progressRef.started.subscribe(function () { return _this.started.emit(); });
        }
        if (this.completed.observers.length) {
            this._completed = this.progressRef.completed.subscribe(function () { return _this.completed.emit(); });
        }
    };
    /**
     * @return {?}
     */
    NgProgressComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._started.unsubscribe();
        this._completed.unsubscribe();
        this.progressRef.destroy();
    };
    /**
     * @return {?}
     */
    NgProgressComponent.prototype.start = /**
     * @return {?}
     */
    function () {
        this.progressRef.start();
    };
    /**
     * @return {?}
     */
    NgProgressComponent.prototype.complete = /**
     * @return {?}
     */
    function () {
        this.progressRef.complete();
    };
    /**
     * @param {?=} n
     * @return {?}
     */
    NgProgressComponent.prototype.inc = /**
     * @param {?=} n
     * @return {?}
     */
    function (n) {
        this.progressRef.inc(n);
    };
    /**
     * @param {?} n
     * @return {?}
     */
    NgProgressComponent.prototype.set = /**
     * @param {?} n
     * @return {?}
     */
    function (n) {
        this.progressRef.set(n);
    };
    NgProgressComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ng-progress',
                    host: {
                        'role': 'progressbar',
                        '[attr.spinnerPosition]': 'spinnerPosition',
                        '[attr.dir]': 'direction',
                        '[attr.thick]': 'thick',
                        '[attr.fixed]': 'fixed'
                    },
                    template: "\n    <ng-container *ngIf=\"state$ | async; let state\">\n      <div class=\"ng-progress-bar\"\n            [class.-active]=\"state.active\"\n            [style.transition]=\"'opacity ' + speed + 'ms ' + ease\">\n        <div class=\"ng-bar-placeholder\">\n          <div class=\"ng-bar\"\n                [style.transform]=\"state.transform\"\n                [style.backgroundColor]=\"color\"\n                [style.transition]=\"state.active ? 'all ' + speed + 'ms ' + ease : 'none'\">\n            <div *ngIf=\"meteor\" class=\"ng-meteor\" [style.boxShadow]=\"'0 0 10px '+ color + ', 0 0 5px ' + color\"></div>\n          </div>\n        </div>\n        <div *ngIf=\"spinner\" class=\"ng-spinner\">\n          <div class=\"ng-spinner-icon\"\n                [style.borderTopColor]=\"color\"\n                [style.borderLeftColor]=\"color\"></div>\n        </div>\n      </div>\n    </ng-container>\n  ",
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    styles: ["ng-progress{z-index:999999;pointer-events:none}ng-progress[fixed=true] .ng-progress-bar,ng-progress[fixed=true] .ng-spinner{position:fixed}ng-progress[fixed=true] .ng-spinner{top:15px}ng-progress[fixed=true][spinnerPosition=left] .ng-spinner{left:15px}ng-progress[fixed=true][spinnerPosition=right] .ng-spinner{right:15px}ng-progress[thick=true] .ng-spinner-icon{width:24px;height:24px;border-width:3px}ng-progress[thick=true] .ng-bar-placeholder{height:3px!important}ng-progress[dir='ltr+'] .ng-meteor,ng-progress[dir=ltr-] .ng-meteor{-webkit-transform:rotate(3deg);transform:rotate(3deg)}ng-progress[dir='ltr+'][thick=true] .ng-meteor,ng-progress[dir=ltr-][thick=true] .ng-meteor{-webkit-transform:rotate(4deg);transform:rotate(4deg)}ng-progress[dir='ltr+'] .ng-bar,ng-progress[dir='rtl+'] .ng-bar{margin-left:-100%}ng-progress[dir='ltr+'] .ng-meteor,ng-progress[dir='rtl+'] .ng-meteor{right:0}ng-progress[dir='ltr+'] .ng-meteor,ng-progress[dir=rtl-] .ng-meteor{top:-3px}ng-progress[dir='ltr+'][thick=true] .ng-meteor,ng-progress[dir=rtl-][thick=true] .ng-meteor{top:-4px}ng-progress[dir='rtl+'] .ng-meteor,ng-progress[dir=ltr-] .ng-meteor{bottom:-3px}ng-progress[dir='rtl+'][thick=true] .ng-meteor,ng-progress[dir=ltr-][thick=true] .ng-meteor{bottom:-4px}ng-progress[dir='rtl+'] .ng-bar-placeholder,ng-progress[dir=ltr-] .ng-bar-placeholder{-webkit-transform:rotate(180deg);transform:rotate(180deg)}ng-progress[dir='rtl+'] .ng-spinner-icon,ng-progress[dir=ltr-] .ng-spinner-icon{animation-direction:reverse}ng-progress[dir='rtl+'] .ng-meteor,ng-progress[dir=rtl-] .ng-meteor{-webkit-transform:rotate(-3deg);transform:rotate(-3deg)}ng-progress[dir='rtl+'][thick=true] .ng-meteor,ng-progress[dir=rtl-][thick=true] .ng-meteor{-webkit-transform:rotate(-4deg);transform:rotate(-4deg)}ng-progress[spinnerPosition=left] .ng-spinner{left:10px}ng-progress[spinnerPosition=right] .ng-spinner{right:10px}.ng-progress-bar{position:relative;z-index:999999;top:0;left:0;width:100%;zoom:1;opacity:0}.ng-progress-bar.-active{opacity:1;transition:none}.ng-bar-placeholder{position:absolute;height:2px;width:100%}.ng-bar{width:100%;height:100%;-webkit-transform:translate(-100%,0,0);transform:translate(-100%,0,0)}.ng-meteor{display:block;position:absolute;width:100px;height:100%;opacity:1}.ng-spinner{position:absolute;display:block;z-index:1031;top:10px}.ng-spinner-icon{width:18px;height:18px;box-sizing:border-box;-webkit-animation:.4s linear infinite spinner-animation;animation:.4s linear infinite spinner-animation;border:2px solid transparent;border-radius:50%}@-webkit-keyframes spinner-animation{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes spinner-animation{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}"]
                }] }
    ];
    /** @nocollapse */
    NgProgressComponent.ctorParameters = function () { return [
        { type: NgProgress }
    ]; };
    NgProgressComponent.propDecorators = {
        id: [{ type: Input }],
        min: [{ type: Input }],
        max: [{ type: Input }],
        ease: [{ type: Input }],
        color: [{ type: Input }],
        speed: [{ type: Input }],
        thick: [{ type: Input }],
        fixed: [{ type: Input }],
        meteor: [{ type: Input }],
        spinner: [{ type: Input }],
        trickleSpeed: [{ type: Input }],
        debounceTime: [{ type: Input }],
        trickleFunc: [{ type: Input }],
        spinnerPosition: [{ type: Input }],
        direction: [{ type: Input }],
        started: [{ type: Output }],
        completed: [{ type: Output }]
    };
    return NgProgressComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var NgProgressModule = /** @class */ (function () {
    function NgProgressModule() {
    }
    /**
     * @param {?=} config
     * @return {?}
     */
    NgProgressModule.forRoot = /**
     * @param {?=} config
     * @return {?}
     */
    function (config) {
        return {
            ngModule: NgProgressModule,
            providers: [
                { provide: CONFIG, useValue: config }
            ]
        };
    };
    NgProgressModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [NgProgressComponent],
                    exports: [NgProgressComponent],
                    imports: [CommonModule]
                },] }
    ];
    return NgProgressModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { NgProgressModule, NgProgressComponent, NgProgressRef, NgProgress, CONFIG };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LXByb2dyZXNzYmFyLWNvcmUuanMubWFwIiwic291cmNlcyI6WyJuZzovL0BuZ3gtcHJvZ3Jlc3NiYXIvY29yZS9saWIvbmctcHJvZ3Jlc3MtcmVmLnRzIiwibmc6Ly9Abmd4LXByb2dyZXNzYmFyL2NvcmUvbGliL25nLXByb2dyZXNzLmludGVyZmFjZS50cyIsIm5nOi8vQG5neC1wcm9ncmVzc2Jhci9jb3JlL2xpYi9uZy1wcm9ncmVzcy5zZXJ2aWNlLnRzIiwibmc6Ly9Abmd4LXByb2dyZXNzYmFyL2NvcmUvbGliL25nLXByb2dyZXNzLmNvbXBvbmVudC50cyIsIm5nOi8vQG5neC1wcm9ncmVzc2Jhci9jb3JlL2xpYi9uZy1wcm9ncmVzcy5tb2R1bGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmdQcm9ncmVzc1N0YXRlLCBOZ1Byb2dyZXNzQ29uZmlnIH0gZnJvbSAnLi9uZy1wcm9ncmVzcy5pbnRlcmZhY2UnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0LCBCZWhhdmlvclN1YmplY3QsIHRpbWVyLCBvZiwgY29tYmluZUxhdGVzdCwgU3Vic2NyaXB0aW9uTGlrZSwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IHRhcCwgbWFwLCBza2lwLCBkZWxheSwgZmlsdGVyLCBkZWJvdW5jZSwgc3dpdGNoTWFwLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbmV4cG9ydCBjbGFzcyBOZ1Byb2dyZXNzUmVmIHtcclxuXHJcbiAgLyoqIFN0cmVhbSB0aGF0IGVtaXRzIHdoZW4gcHJvZ3Jlc3Mgc3RhdGUgaXMgY2hhbmdlZCAqL1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgX3N0YXRlOiBCZWhhdmlvclN1YmplY3Q8TmdQcm9ncmVzc1N0YXRlPjtcclxuICBzdGF0ZTogT2JzZXJ2YWJsZTxOZ1Byb2dyZXNzU3RhdGU+O1xyXG5cclxuICAvKiogU3RyZWFtIHRoYXQgZW1pdHMgd2hlbiBjb25maWcgaXMgY2hhbmdlZCAqL1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgX2NvbmZpZzogQmVoYXZpb3JTdWJqZWN0PE5nUHJvZ3Jlc3NDb25maWc+O1xyXG4gIGNvbmZpZzogT2JzZXJ2YWJsZTxOZ1Byb2dyZXNzU3RhdGU+O1xyXG5cclxuICAvKiogU3RyZWFtIHRoYXQgaW5jcmVtZW50cyBhbmQgdXBkYXRlcyBwcm9ncmVzcyBzdGF0ZSAqL1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgX3RyaWNrbGluZyA9IG5ldyBTdWJqZWN0KCk7XHJcblxyXG4gIC8qKiBTdHJlYW0gdGhhdCBjb21iaW5lcyBcIl90cmlja2xpbmdcIiBhbmQgXCJjb25maWdcIiBzdHJlYW1zICovXHJcbiAgcHJpdmF0ZSByZWFkb25seSBfd29ya2VyOiBTdWJzY3JpcHRpb25MaWtlID0gU3Vic2NyaXB0aW9uLkVNUFRZO1xyXG5cclxuICAvKiogR2V0IGN1cnJlbnQgcHJvZ3Jlc3Mgc3RhdGUgKi9cclxuICBwcml2YXRlIGdldCBjdXJyU3RhdGUoKTogTmdQcm9ncmVzc1N0YXRlIHtcclxuICAgIHJldHVybiB0aGlzLl9zdGF0ZS52YWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKiBDaGVjayBpZiBwcm9ncmVzcyBoYXMgc3RhcnRlZCAqL1xyXG4gIGdldCBpc1N0YXJ0ZWQoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5jdXJyU3RhdGUuYWN0aXZlO1xyXG4gIH1cclxuXHJcbiAgLyoqIFByb2dyZXNzIHN0YXJ0IGV2ZW50ICovXHJcbiAgZ2V0IHN0YXJ0ZWQoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XHJcbiAgICByZXR1cm4gdGhpcy5fc3RhdGUucGlwZShcclxuICAgICAgbWFwKChzdGF0ZTogTmdQcm9ncmVzc1N0YXRlKSA9PiBzdGF0ZS5hY3RpdmUpLFxyXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxyXG4gICAgICBmaWx0ZXIoYWN0aXZlID0+IGFjdGl2ZSlcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKiogUHJvZ3Jlc3MgZW5kZWQgZXZlbnQgKi9cclxuICBnZXQgY29tcGxldGVkKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlLnBpcGUoXHJcbiAgICAgIG1hcCgoc3RhdGU6IE5nUHJvZ3Jlc3NTdGF0ZSkgPT4gc3RhdGUuYWN0aXZlKSxcclxuICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcclxuICAgICAgZmlsdGVyKGFjdGl2ZSA9PiAhYWN0aXZlKSxcclxuICAgICAgc2tpcCgxKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yKGN1c3RvbUNvbmZpZzogTmdQcm9ncmVzc0NvbmZpZywgcHJpdmF0ZSBkZWxldGVJbnN0YW5jZTogRnVuY3Rpb24pIHtcclxuICAgIHRoaXMuX3N0YXRlID0gbmV3IEJlaGF2aW9yU3ViamVjdDxOZ1Byb2dyZXNzU3RhdGU+KHthY3RpdmU6IGZhbHNlLCB2YWx1ZTogMH0pO1xyXG4gICAgdGhpcy5fY29uZmlnID0gbmV3IEJlaGF2aW9yU3ViamVjdDxOZ1Byb2dyZXNzQ29uZmlnPihjdXN0b21Db25maWcpO1xyXG4gICAgdGhpcy5zdGF0ZSA9IHRoaXMuX3N0YXRlLmFzT2JzZXJ2YWJsZSgpO1xyXG4gICAgdGhpcy5jb25maWcgPSB0aGlzLl9zdGF0ZS5hc09ic2VydmFibGUoKTtcclxuXHJcbiAgICB0aGlzLl93b3JrZXIgPSBjb21iaW5lTGF0ZXN0KHRoaXMuX3RyaWNrbGluZywgdGhpcy5fY29uZmlnKS5waXBlKFxyXG4gICAgICBkZWJvdW5jZSgoW3N0YXJ0LCBjb25maWddOiBbYm9vbGVhbiwgTmdQcm9ncmVzc0NvbmZpZ10pID0+IHRpbWVyKHN0YXJ0ID8gY29uZmlnLmRlYm91bmNlVGltZSA6IDApKSxcclxuICAgICAgc3dpdGNoTWFwKChbc3RhcnQsIGNvbmZpZ106IFtib29sZWFuLCBOZ1Byb2dyZXNzQ29uZmlnXSkgPT4gc3RhcnQgPyB0aGlzLm9uVHJpY2tsaW5nKGNvbmZpZykgOiB0aGlzLm9uQ29tcGxldGUoY29uZmlnKSlcclxuICAgICkuc3Vic2NyaWJlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydCB0aGUgcHJvZ3Jlc3NcclxuICAgKi9cclxuICBzdGFydCgpIHtcclxuICAgIHRoaXMuX3RyaWNrbGluZy5uZXh0KHRydWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29tcGxldGUgdGhlIHByb2dyZXNzXHJcbiAgICovXHJcbiAgY29tcGxldGUoKSB7XHJcbiAgICB0aGlzLl90cmlja2xpbmcubmV4dChmYWxzZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbmNyZW1lbnQgdGhlIHByb2dyZXNzXHJcbiAgICogQHBhcmFtIGFtb3VudFxyXG4gICAqL1xyXG4gIGluYyhhbW91bnQ/OiBudW1iZXIpIHtcclxuICAgIGNvbnN0IG4gPSB0aGlzLmN1cnJTdGF0ZS52YWx1ZTtcclxuICAgIGlmICghdGhpcy5pc1N0YXJ0ZWQpIHtcclxuICAgICAgdGhpcy5zdGFydCgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHR5cGVvZiBhbW91bnQgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgYW1vdW50ID0gdGhpcy5fY29uZmlnLnZhbHVlLnRyaWNrbGVGdW5jKG4pO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuc2V0KG4gKyBhbW91bnQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHRoZSBwcm9ncmVzc1xyXG4gICAqIEBwYXJhbSBuXHJcbiAgICovXHJcbiAgc2V0KG46IG51bWJlcikge1xyXG4gICAgdGhpcy5zZXRTdGF0ZSh7dmFsdWU6IHRoaXMuY2xhbXAobiksIGFjdGl2ZTogdHJ1ZX0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IGNvbmZpZ1xyXG4gICAqIEBwYXJhbSBjb25maWdcclxuICAgKi9cclxuICBzZXRDb25maWcoY29uZmlnOiBOZ1Byb2dyZXNzQ29uZmlnKSB7XHJcbiAgICB0aGlzLl9jb25maWcubmV4dCh7Li4udGhpcy5fY29uZmlnLnZhbHVlLCAuLi5jb25maWd9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlc3Ryb3kgcHJvZ3Jlc3MgcmVmZXJlbmNlXHJcbiAgICovXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMuX3dvcmtlci51bnN1YnNjcmliZSgpO1xyXG4gICAgdGhpcy5fdHJpY2tsaW5nLmNvbXBsZXRlKCk7XHJcbiAgICB0aGlzLl9zdGF0ZS5jb21wbGV0ZSgpO1xyXG4gICAgdGhpcy5fY29uZmlnLmNvbXBsZXRlKCk7XHJcbiAgICB0aGlzLmRlbGV0ZUluc3RhbmNlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgcHJvZ3Jlc3Mgc3RhdGVcclxuICAgKiBAcGFyYW0gc3RhdGVcclxuICAgKi9cclxuICBwcml2YXRlIHNldFN0YXRlKHN0YXRlOiBOZ1Byb2dyZXNzU3RhdGUpIHtcclxuICAgIHRoaXMuX3N0YXRlLm5leHQoey4uLnRoaXMuY3VyclN0YXRlLCAuLi5zdGF0ZX0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2xhbXBzIGEgdmFsdWUgdG8gYmUgYmV0d2VlbiBtaW4gYW5kIG1heFxyXG4gICAqIEBwYXJhbSBuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBjbGFtcChuOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuX2NvbmZpZy52YWx1ZS5taW4sIE1hdGgubWluKHRoaXMuX2NvbmZpZy52YWx1ZS5tYXgsIG4pKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEtlZXBzIGluY3JlbWVudGluZyB0aGUgcHJvZ3Jlc3NcclxuICAgKiBAcGFyYW0gY29uZmlnXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBvblRyaWNrbGluZyhjb25maWc6IE5nUHJvZ3Jlc3NDb25maWcpOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xyXG4gICAgaWYgKCF0aGlzLmlzU3RhcnRlZCkge1xyXG4gICAgICB0aGlzLnNldCh0aGlzLl9jb25maWcudmFsdWUubWluKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aW1lcigwLCBjb25maWcudHJpY2tsZVNwZWVkKS5waXBlKHRhcCgoKSA9PiB0aGlzLmluYygpKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb21wbGV0ZXMgdGhlbiByZXNldHMgdGhlIHByb2dyZXNzXHJcbiAgICogQHBhcmFtIGNvbmZpZ1xyXG4gICAqL1xyXG4gIHByaXZhdGUgb25Db21wbGV0ZShjb25maWc6IE5nUHJvZ3Jlc3NDb25maWcpOiBPYnNlcnZhYmxlPGFueT4ge1xyXG4gICAgcmV0dXJuICF0aGlzLmlzU3RhcnRlZCA/IG9mKHt9KSA6IG9mKHt9KS5waXBlKFxyXG4gICAgICAvLyBDb21wbGV0ZXMgdGhlIHByb2dyZXNzXHJcbiAgICAgIHRhcCgoKSA9PiB0aGlzLnNldFN0YXRlKHt2YWx1ZTogMTAwfSkpLFxyXG5cclxuICAgICAgLy8gSGlkZXMgdGhlIHByb2dyZXNzIGJhciBhZnRlciBhIHRpbnkgZGVsYXlcclxuICAgICAgZGVsYXkoY29uZmlnLnNwZWVkICogMS43KSxcclxuICAgICAgdGFwKCgpID0+IHRoaXMuc2V0U3RhdGUoe2FjdGl2ZTogZmFsc2V9KSksXHJcblxyXG4gICAgICAvLyBSZXNldHMgdGhlIHByb2dyZXNzIHN0YXRlXHJcbiAgICAgIGRlbGF5KGNvbmZpZy5zcGVlZCksXHJcbiAgICAgIHRhcCgoKSA9PiB0aGlzLnNldFN0YXRlKHt2YWx1ZTogMH0pKVxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgSW5qZWN0aW9uVG9rZW4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTmdQcm9ncmVzc1N0YXRlIHtcclxuICBhY3RpdmU/OiBib29sZWFuO1xyXG4gIHZhbHVlPzogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE5nUHJvZ3Jlc3NDb25maWcge1xyXG4gIHNwaW5uZXJQb3NpdGlvbj86ICdsZWZ0JyB8ICdyaWdodCc7XHJcbiAgZGlyZWN0aW9uPzogJ2x0cisnIHwgJ2x0ci0nIHwgJ3J0bCsnIHwgJ3J0bC0nO1xyXG4gIGVhc2U/OiBzdHJpbmc7XHJcbiAgY29sb3I/OiBzdHJpbmc7XHJcbiAgdGhpY2s/OiBib29sZWFuO1xyXG4gIGZpeGVkPzogYm9vbGVhbjtcclxuICBtZXRlb3I/OiBib29sZWFuO1xyXG4gIHNwaW5uZXI/OiBib29sZWFuO1xyXG4gIG1heD86IG51bWJlcjtcclxuICBtaW4/OiBudW1iZXI7XHJcbiAgc3BlZWQ/OiBudW1iZXI7XHJcbiAgdHJpY2tsZVNwZWVkPzogbnVtYmVyO1xyXG4gIHRyaWNrbGVGdW5jPzogKG46IG51bWJlcikgPT4gbnVtYmVyO1xyXG4gIGRlYm91bmNlVGltZT86IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IENPTkZJRyA9IG5ldyBJbmplY3Rpb25Ub2tlbjxOZ1Byb2dyZXNzQ29uZmlnPignY29uZmlnJyk7XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdCwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgTmdQcm9ncmVzc1JlZiB9IGZyb20gJy4vbmctcHJvZ3Jlc3MtcmVmJztcclxuaW1wb3J0IHsgTmdQcm9ncmVzc0NvbmZpZywgQ09ORklHIH0gZnJvbSAnLi9uZy1wcm9ncmVzcy5pbnRlcmZhY2UnO1xyXG5cclxuY29uc3QgZGVmYXVsdENvbmZpZzogTmdQcm9ncmVzc0NvbmZpZyA9IHtcclxuICBtaW46IDgsXHJcbiAgbWF4OiAxMDAsXHJcbiAgc3BlZWQ6IDIwMCxcclxuICBkZWJvdW5jZVRpbWU6IDAsXHJcbiAgdHJpY2tsZVNwZWVkOiAzMDAsXHJcbiAgZml4ZWQ6IHRydWUsXHJcbiAgbWV0ZW9yOiB0cnVlLFxyXG4gIHRoaWNrOiBmYWxzZSxcclxuICBzcGlubmVyOiB0cnVlLFxyXG4gIGVhc2U6ICdsaW5lYXInLFxyXG4gIGNvbG9yOiAnIzFCOTVFMCcsXHJcbiAgZGlyZWN0aW9uOiAnbHRyKycsXHJcbiAgc3Bpbm5lclBvc2l0aW9uOiAncmlnaHQnLFxyXG4gIHRyaWNrbGVGdW5jOiAobjogbnVtYmVyKTogbnVtYmVyID0+IHtcclxuICAgIGlmIChuID49IDAgJiYgbiA8IDIwKSByZXR1cm4gMTA7XHJcbiAgICBpZiAobiA+PSAyMCAmJiBuIDwgNTApIHJldHVybiA0O1xyXG4gICAgaWYgKG4gPj0gNTAgJiYgbiA8IDgwKSByZXR1cm4gMjtcclxuICAgIGlmIChuID49IDgwICYmIG4gPCA5OSkgcmV0dXJuIDAuNTtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxufTtcclxuXHJcbkBJbmplY3RhYmxlKHtcclxuICBwcm92aWRlZEluOiAncm9vdCdcclxufSlcclxuZXhwb3J0IGNsYXNzIE5nUHJvZ3Jlc3Mge1xyXG5cclxuICAvKiogU3RvcmUgcHJvZ3Jlc3MgYmFyIGluc3RhbmNlcyAqL1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgX2luc3RhbmNlcyA9IG5ldyBNYXA8c3RyaW5nLCBOZ1Byb2dyZXNzUmVmPigpO1xyXG5cclxuICAvKiogR2xvYmFsIGNvbmZpZyAqL1xyXG4gIGNvbmZpZzogTmdQcm9ncmVzc0NvbmZpZztcclxuXHJcbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgQEluamVjdChDT05GSUcpIGNvbmZpZzogTmdQcm9ncmVzc0NvbmZpZykge1xyXG4gICAgdGhpcy5jb25maWcgPSB7Li4uZGVmYXVsdENvbmZpZywgLi4uY29uZmlnfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBvciBDcmVhdGUgcHJvZ3Jlc3MgYmFyIGJ5IElEXHJcbiAgICogQHBhcmFtIGlkXHJcbiAgICogQHBhcmFtIGNvbmZpZ1xyXG4gICAqL1xyXG4gIHJlZihpZCA9ICdyb290JywgY29uZmlnPzogTmdQcm9ncmVzc0NvbmZpZykge1xyXG4gICAgaWYgKHRoaXMuX2luc3RhbmNlcy5oYXMoaWQpKSB7XHJcbiAgICAgIC8vIEdldCBQcm9ncmVzc1JlZiBpbnN0YW5jZVxyXG4gICAgICBjb25zdCBwcm9ncmVzc1JlZiA9IHRoaXMuX2luc3RhbmNlcy5nZXQoaWQpO1xyXG4gICAgICBpZiAoY29uZmlnKSB7XHJcbiAgICAgICAgcHJvZ3Jlc3NSZWYuc2V0Q29uZmlnKHsuLi50aGlzLmNvbmZpZywgLi4uY29uZmlnfSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHByb2dyZXNzUmVmO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gQ3JlYXRlIG5ldyBQcm9ncmVzc1JlZiBpbnN0YW5jZVxyXG4gICAgICBjb25zdCBwcm9ncmVzc1JlZiA9IG5ldyBOZ1Byb2dyZXNzUmVmKHsuLi50aGlzLmNvbmZpZywgLi4uY29uZmlnfSwgdGhpcy5kZWxldGVJbnN0YW5jZShpZCkpO1xyXG4gICAgICByZXR1cm4gdGhpcy5faW5zdGFuY2VzLnNldChpZCwgcHJvZ3Jlc3NSZWYpLmdldChpZCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXN0cm95IGFsbCBwcm9ncmVzcyBiYXIgaW5zdGFuY2VzXHJcbiAgICovXHJcbiAgZGVzdHJveUFsbCgpIHtcclxuICAgIHRoaXMuX2luc3RhbmNlcy5mb3JFYWNoKChyZWY6IE5nUHJvZ3Jlc3NSZWYpID0+IHJlZi5kZXN0cm95KCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQSBkZXN0cm95ZXIgZnVuY3Rpb24gZm9yIGVhY2ggcHJvZ3Jlc3MgYmFyIGluc3RhbmNlXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBkZWxldGVJbnN0YW5jZShpZDogc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICB0aGlzLl9pbnN0YW5jZXMuZGVsZXRlKGlkKTtcclxuICAgIH07XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7XHJcbiAgQ29tcG9uZW50LFxyXG4gIElucHV0LFxyXG4gIE9uQ2hhbmdlcyxcclxuICBPbkRlc3Ryb3ksXHJcbiAgT25Jbml0LFxyXG4gIE91dHB1dCxcclxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcclxuICBFdmVudEVtaXR0ZXIsXHJcbiAgVmlld0VuY2Fwc3VsYXRpb25cclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3Vic2NyaXB0aW9uLCBTdWJzY3JpcHRpb25MaWtlfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBOZ1Byb2dyZXNzIH0gZnJvbSAnLi9uZy1wcm9ncmVzcy5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTmdQcm9ncmVzc1JlZiB9IGZyb20gJy4vbmctcHJvZ3Jlc3MtcmVmJztcclxuaW1wb3J0IHsgTmdQcm9ncmVzc1N0YXRlIH0gZnJvbSAnLi9uZy1wcm9ncmVzcy5pbnRlcmZhY2UnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICduZy1wcm9ncmVzcycsXHJcbiAgaG9zdDoge1xyXG4gICAgJ3JvbGUnOiAncHJvZ3Jlc3NiYXInLFxyXG4gICAgJ1thdHRyLnNwaW5uZXJQb3NpdGlvbl0nOiAnc3Bpbm5lclBvc2l0aW9uJyxcclxuICAgICdbYXR0ci5kaXJdJzogJ2RpcmVjdGlvbicsXHJcbiAgICAnW2F0dHIudGhpY2tdJzogJ3RoaWNrJyxcclxuICAgICdbYXR0ci5maXhlZF0nOiAnZml4ZWQnXHJcbiAgfSxcclxuICB0ZW1wbGF0ZTogYFxyXG4gICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cInN0YXRlJCB8IGFzeW5jOyBsZXQgc3RhdGVcIj5cclxuICAgICAgPGRpdiBjbGFzcz1cIm5nLXByb2dyZXNzLWJhclwiXHJcbiAgICAgICAgICAgIFtjbGFzcy4tYWN0aXZlXT1cInN0YXRlLmFjdGl2ZVwiXHJcbiAgICAgICAgICAgIFtzdHlsZS50cmFuc2l0aW9uXT1cIidvcGFjaXR5ICcgKyBzcGVlZCArICdtcyAnICsgZWFzZVwiPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJuZy1iYXItcGxhY2Vob2xkZXJcIj5cclxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJuZy1iYXJcIlxyXG4gICAgICAgICAgICAgICAgW3N0eWxlLnRyYW5zZm9ybV09XCJzdGF0ZS50cmFuc2Zvcm1cIlxyXG4gICAgICAgICAgICAgICAgW3N0eWxlLmJhY2tncm91bmRDb2xvcl09XCJjb2xvclwiXHJcbiAgICAgICAgICAgICAgICBbc3R5bGUudHJhbnNpdGlvbl09XCJzdGF0ZS5hY3RpdmUgPyAnYWxsICcgKyBzcGVlZCArICdtcyAnICsgZWFzZSA6ICdub25lJ1wiPlxyXG4gICAgICAgICAgICA8ZGl2ICpuZ0lmPVwibWV0ZW9yXCIgY2xhc3M9XCJuZy1tZXRlb3JcIiBbc3R5bGUuYm94U2hhZG93XT1cIicwIDAgMTBweCAnKyBjb2xvciArICcsIDAgMCA1cHggJyArIGNvbG9yXCI+PC9kaXY+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2ICpuZ0lmPVwic3Bpbm5lclwiIGNsYXNzPVwibmctc3Bpbm5lclwiPlxyXG4gICAgICAgICAgPGRpdiBjbGFzcz1cIm5nLXNwaW5uZXItaWNvblwiXHJcbiAgICAgICAgICAgICAgICBbc3R5bGUuYm9yZGVyVG9wQ29sb3JdPVwiY29sb3JcIlxyXG4gICAgICAgICAgICAgICAgW3N0eWxlLmJvcmRlckxlZnRDb2xvcl09XCJjb2xvclwiPjwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvbmctY29udGFpbmVyPlxyXG4gIGAsXHJcbiAgc3R5bGVVcmxzOiBbJy4vbmctcHJvZ3Jlc3MuY29tcG9uZW50LnNjc3MnXSxcclxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxyXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG4gIHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhbHNlXHJcbn0pXHJcblxyXG5leHBvcnQgY2xhc3MgTmdQcm9ncmVzc0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xyXG5cclxuICBwcml2YXRlIF9zdGFydGVkOiBTdWJzY3JpcHRpb25MaWtlID0gU3Vic2NyaXB0aW9uLkVNUFRZO1xyXG4gIHByaXZhdGUgX2NvbXBsZXRlZDogU3Vic2NyaXB0aW9uTGlrZSA9IFN1YnNjcmlwdGlvbi5FTVBUWTtcclxuXHJcbiAgLyoqIFByb2dyZXNzIGJhciB3b3JrZXIgKi9cclxuICBwcm9ncmVzc1JlZjogTmdQcm9ncmVzc1JlZjtcclxuXHJcbiAgLyoqIFN0cmVhbSB0aGF0IGVtaXRzIHByb2dyZXNzIHN0YXRlICovXHJcbiAgc3RhdGUkOiBPYnNlcnZhYmxlPHsgYWN0aXZlOiBib29sZWFuLCB0cmFuc2Zvcm06IHN0cmluZyB9PjtcclxuXHJcbiAgLyoqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2UgaWYgaWQgaXMgbm90IGFscmVhZHkgZXhpc3RzICovXHJcbiAgQElucHV0KCkgaWQgPSAncm9vdCc7XHJcblxyXG4gIC8qKiBJbml0aWFsaXplcyBpbnB1dHMgZnJvbSB0aGUgZ2xvYmFsIGNvbmZpZyAqL1xyXG4gIEBJbnB1dCgpIG1pbjogbnVtYmVyID0gdGhpcy5fbmdQcm9ncmVzcy5jb25maWcubWluO1xyXG4gIEBJbnB1dCgpIG1heDogbnVtYmVyID0gdGhpcy5fbmdQcm9ncmVzcy5jb25maWcubWF4O1xyXG4gIEBJbnB1dCgpIGVhc2U6IHN0cmluZyA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLmVhc2U7XHJcbiAgQElucHV0KCkgY29sb3I6IHN0cmluZyA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLmNvbG9yO1xyXG4gIEBJbnB1dCgpIHNwZWVkOiBudW1iZXIgPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy5zcGVlZDtcclxuICBASW5wdXQoKSB0aGljazogYm9vbGVhbiA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLnRoaWNrO1xyXG4gIEBJbnB1dCgpIGZpeGVkOiBib29sZWFuID0gdGhpcy5fbmdQcm9ncmVzcy5jb25maWcuZml4ZWQ7XHJcbiAgQElucHV0KCkgbWV0ZW9yOiBib29sZWFuID0gdGhpcy5fbmdQcm9ncmVzcy5jb25maWcubWV0ZW9yO1xyXG4gIEBJbnB1dCgpIHNwaW5uZXI6IGJvb2xlYW4gPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy5zcGlubmVyO1xyXG4gIEBJbnB1dCgpIHRyaWNrbGVTcGVlZDogbnVtYmVyID0gdGhpcy5fbmdQcm9ncmVzcy5jb25maWcudHJpY2tsZVNwZWVkO1xyXG4gIEBJbnB1dCgpIGRlYm91bmNlVGltZTogbnVtYmVyID0gdGhpcy5fbmdQcm9ncmVzcy5jb25maWcuZGVib3VuY2VUaW1lO1xyXG4gIEBJbnB1dCgpIHRyaWNrbGVGdW5jOiAobjogbnVtYmVyKSA9PiBudW1iZXIgPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy50cmlja2xlRnVuYztcclxuICBASW5wdXQoKSBzcGlubmVyUG9zaXRpb246ICdsZWZ0JyB8ICdyaWdodCcgPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy5zcGlubmVyUG9zaXRpb247XHJcbiAgQElucHV0KCkgZGlyZWN0aW9uOiAnbHRyKycgfCAnbHRyLScgfCAncnRsKycgfCAncnRsLScgPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy5kaXJlY3Rpb247XHJcbiAgQE91dHB1dCgpIHN0YXJ0ZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgQE91dHB1dCgpIGNvbXBsZXRlZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuXHJcbiAgZ2V0IGlzU3RhcnRlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLnByb2dyZXNzUmVmLmlzU3RhcnRlZDtcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX25nUHJvZ3Jlc3M6IE5nUHJvZ3Jlc3MpIHtcclxuICB9XHJcblxyXG4gIG5nT25DaGFuZ2VzKCkge1xyXG4gICAgaWYgKHRoaXMucHJvZ3Jlc3NSZWYgaW5zdGFuY2VvZiBOZ1Byb2dyZXNzUmVmKSB7XHJcbiAgICAgIC8vIFVwZGF0ZSBwcm9ncmVzcyBiYXIgY29uZmlnIHdoZW4gaW5wdXRzIGNoYW5nZVxyXG4gICAgICB0aGlzLnByb2dyZXNzUmVmLnNldENvbmZpZyh7XHJcbiAgICAgICAgbWF4OiAodGhpcy5tYXggPiAwICYmIHRoaXMubWF4IDw9IDEwMCkgPyB0aGlzLm1heCA6IDEwMCxcclxuICAgICAgICBtaW46ICh0aGlzLm1pbiA8IDEwMCAmJiB0aGlzLm1pbiA+PSAwKSA/IHRoaXMubWluIDogMCxcclxuICAgICAgICBzcGVlZDogdGhpcy5zcGVlZCxcclxuICAgICAgICB0cmlja2xlU3BlZWQ6IHRoaXMudHJpY2tsZVNwZWVkLFxyXG4gICAgICAgIHRyaWNrbGVGdW5jOiB0aGlzLnRyaWNrbGVGdW5jLFxyXG4gICAgICAgIGRlYm91bmNlVGltZTogdGhpcy5kZWJvdW5jZVRpbWVcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBuZ09uSW5pdCgpIHtcclxuICAgIC8vIEdldCBwcm9ncmVzcyBiYXIgc2VydmljZSBpbnN0YW5jZVxyXG4gICAgdGhpcy5wcm9ncmVzc1JlZiA9IHRoaXMuX25nUHJvZ3Jlc3MucmVmKHRoaXMuaWQsIHtcclxuICAgICAgbWF4OiB0aGlzLm1heCxcclxuICAgICAgbWluOiB0aGlzLm1pbixcclxuICAgICAgc3BlZWQ6IHRoaXMuc3BlZWQsXHJcbiAgICAgIHRyaWNrbGVTcGVlZDogdGhpcy50cmlja2xlU3BlZWQsXHJcbiAgICAgIGRlYm91bmNlVGltZTogdGhpcy5kZWJvdW5jZVRpbWVcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFN1YnNjcmliZSB0byBwcm9ncmVzcyBzdGF0ZVxyXG4gICAgdGhpcy5zdGF0ZSQgPSB0aGlzLnByb2dyZXNzUmVmLnN0YXRlLnBpcGUoXHJcbiAgICAgIG1hcCgoc3RhdGU6IE5nUHJvZ3Jlc3NTdGF0ZSkgPT4gKHtcclxuICAgICAgICBhY3RpdmU6IHN0YXRlLmFjdGl2ZSxcclxuICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke3N0YXRlLnZhbHVlfSUsMCwwKWBcclxuICAgICAgfSkpXHJcbiAgICApO1xyXG5cclxuICAgIC8vIFN1YnNjcmliZXMgdG8gc3RhcnRlZCBhbmQgY29tcGxldGVkIGV2ZW50cyBvbiBkZW1hblxyXG4gICAgaWYgKHRoaXMuc3RhcnRlZC5vYnNlcnZlcnMubGVuZ3RoKSB7XHJcbiAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0aGlzLnByb2dyZXNzUmVmLnN0YXJ0ZWQuc3Vic2NyaWJlKCgpID0+IHRoaXMuc3RhcnRlZC5lbWl0KCkpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuY29tcGxldGVkLm9ic2VydmVycy5sZW5ndGgpIHtcclxuICAgICAgdGhpcy5fY29tcGxldGVkID0gdGhpcy5wcm9ncmVzc1JlZi5jb21wbGV0ZWQuc3Vic2NyaWJlKCgpID0+IHRoaXMuY29tcGxldGVkLmVtaXQoKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBuZ09uRGVzdHJveSgpIHtcclxuICAgIHRoaXMuX3N0YXJ0ZWQudW5zdWJzY3JpYmUoKTtcclxuICAgIHRoaXMuX2NvbXBsZXRlZC51bnN1YnNjcmliZSgpO1xyXG4gICAgdGhpcy5wcm9ncmVzc1JlZi5kZXN0cm95KCk7XHJcbiAgfVxyXG5cclxuICBzdGFydCgpIHtcclxuICAgIHRoaXMucHJvZ3Jlc3NSZWYuc3RhcnQoKTtcclxuICB9XHJcblxyXG4gIGNvbXBsZXRlKCkge1xyXG4gICAgdGhpcy5wcm9ncmVzc1JlZi5jb21wbGV0ZSgpO1xyXG4gIH1cclxuXHJcbiAgaW5jKG4/OiBudW1iZXIpIHtcclxuICAgIHRoaXMucHJvZ3Jlc3NSZWYuaW5jKG4pO1xyXG4gIH1cclxuXHJcbiAgc2V0KG46IG51bWJlcikge1xyXG4gICAgdGhpcy5wcm9ncmVzc1JlZi5zZXQobik7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IE1vZHVsZVdpdGhQcm92aWRlcnMsIE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7IE5nUHJvZ3Jlc3NDb21wb25lbnQgfSBmcm9tICcuL25nLXByb2dyZXNzLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IE5nUHJvZ3Jlc3NDb25maWcsIENPTkZJRyB9IGZyb20gJy4vbmctcHJvZ3Jlc3MuaW50ZXJmYWNlJztcclxuXHJcbkBOZ01vZHVsZSh7XHJcbiAgZGVjbGFyYXRpb25zOiBbTmdQcm9ncmVzc0NvbXBvbmVudF0sXHJcbiAgZXhwb3J0czogW05nUHJvZ3Jlc3NDb21wb25lbnRdLFxyXG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBOZ1Byb2dyZXNzTW9kdWxlIHtcclxuICBzdGF0aWMgZm9yUm9vdChjb25maWc/OiBOZ1Byb2dyZXNzQ29uZmlnKTogTW9kdWxlV2l0aFByb3ZpZGVycyB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBuZ01vZHVsZTogTmdQcm9ncmVzc01vZHVsZSxcclxuICAgICAgcHJvdmlkZXJzOiBbXHJcbiAgICAgICAge3Byb3ZpZGU6IENPTkZJRywgdXNlVmFsdWU6IGNvbmZpZ31cclxuICAgICAgXVxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7SUFJQTtJQTZDRSx1QkFBWSxZQUE4QixFQUFVLGNBQXdCO1FBQTVFLGlCQVVDO1FBVm1ELG1CQUFjLEdBQWQsY0FBYyxDQUFVOzs7OzBCQWxDOUMsSUFBSSxPQUFPLEVBQUU7Ozs7dUJBR0UsWUFBWSxDQUFDLEtBQUs7UUFnQzdELElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxlQUFlLENBQWtCLEVBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFDLENBQUMsQ0FBQztRQUM5RSxJQUFJLENBQUMsT0FB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