/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Subject, BehaviorSubject, timer, of, combineLatest, Subscription } from 'rxjs';
import { tap, map, skip, delay, filter, debounce, switchMap, distinctUntilChanged } from 'rxjs/operators';
var NgProgressRef = /** @class */ (function () {
    function NgProgressRef(customConfig, deleteInstance) {
        var _this = this;
        this.deleteInstance = deleteInstance;
        /**
         * Stream that increments and updates progress state
         */
        this._trickling = new Subject();
        /**
         * Stream that combines "_trickling" and "config" streams
         */
        this._worker = Subscription.EMPTY;
        this._state = new BehaviorSubject({ active: false, value: 0 });
        this._config = new BehaviorSubject(customConfig);
        this.state = this._state.asObservable();
        this.config = this._state.asObservable();
        this._worker = combineLatest(this._trickling, this._config).pipe(debounce(function (_a) {
            var _b = tslib_1.__read(_a, 2), start = _b[0], config = _b[1];
            return timer(start ? config.debounceTime : 0);
        }), switchMap(function (_a) {
            var _b = tslib_1.__read(_a, 2), start = _b[0], config = _b[1];
            return start ? _this.onTrickling(config) : _this.onComplete(config);
        })).subscribe();
    }
    Object.defineProperty(NgProgressRef.prototype, "currState", {
        get: /**
         * Get current progress state
         * @return {?}
         */
        function () {
            return this._state.value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgProgressRef.prototype, "isStarted", {
        /** Check if progress has started */
        get: /**
         * Check if progress has started
         * @return {?}
         */
        function () {
            return this.currState.active;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgProgressRef.prototype, "started", {
        /** Progress start event */
        get: /**
         * Progress start event
         * @return {?}
         */
        function () {
            return this._state.pipe(map(function (state) { return state.active; }), distinctUntilChanged(), filter(function (active) { return active; }));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgProgressRef.prototype, "completed", {
        /** Progress ended event */
        get: /**
         * Progress ended event
         * @return {?}
         */
        function () {
            return this._state.pipe(map(function (state) { return state.active; }), distinctUntilChanged(), filter(function (active) { return !active; }), skip(1));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Start the progress
     */
    /**
     * Start the progress
     * @return {?}
     */
    NgProgressRef.prototype.start = /**
     * Start the progress
     * @return {?}
     */
    function () {
        this._trickling.next(true);
    };
    /**
     * Complete the progress
     */
    /**
     * Complete the progress
     * @return {?}
     */
    NgProgressRef.prototype.complete = /**
     * Complete the progress
     * @return {?}
     */
    function () {
        this._trickling.next(false);
    };
    /**
     * Increment the progress
     * @param amount
     */
    /**
     * Increment the progress
     * @param {?=} amount
     * @return {?}
     */
    NgProgressRef.prototype.inc = /**
     * Increment the progress
     * @param {?=} amount
     * @return {?}
     */
    function (amount) {
        /** @type {?} */
        var n = this.currState.value;
        if (!this.isStarted) {
            this.start();
        }
        else {
            if (typeof amount !== 'number') {
                amount = this._config.value.trickleFunc(n);
            }
            this.set(n + amount);
        }
    };
    /**
     * Set the progress
     * @param n
     */
    /**
     * Set the progress
     * @param {?} n
     * @return {?}
     */
    NgProgressRef.prototype.set = /**
     * Set the progress
     * @param {?} n
     * @return {?}
     */
    function (n) {
        this.setState({ value: this.clamp(n), active: true });
    };
    /**
     * Set config
     * @param config
     */
    /**
     * Set config
     * @param {?} config
     * @return {?}
     */
    NgProgressRef.prototype.setConfig = /**
     * Set config
     * @param {?} config
     * @return {?}
     */
    function (config) {
        this._config.next(tslib_1.__assign({}, this._config.value, config));
    };
    /**
     * Destroy progress reference
     */
    /**
     * Destroy progress reference
     * @return {?}
     */
    NgProgressRef.prototype.destroy = /**
     * Destroy progress reference
     * @return {?}
     */
    function () {
        this._worker.unsubscribe();
        this._trickling.complete();
        this._state.complete();
        this._config.complete();
        this.deleteInstance();
    };
    /**
     * Set progress state
     * @param {?} state
     * @return {?}
     */
    NgProgressRef.prototype.setState = /**
     * Set progress state
     * @param {?} state
     * @return {?}
     */
    function (state) {
        this._state.next(tslib_1.__assign({}, this.currState, state));
    };
    /**
     * Clamps a value to be between min and max
     * @param {?} n
     * @return {?}
     */
    NgProgressRef.prototype.clamp = /**
     * Clamps a value to be between min and max
     * @param {?} n
     * @return {?}
     */
    function (n) {
        return Math.max(this._config.value.min, Math.min(this._config.value.max, n));
    };
    /**
     * Keeps incrementing the progress
     * @param {?} config
     * @return {?}
     */
    NgProgressRef.prototype.onTrickling = /**
     * Keeps incrementing the progress
     * @param {?} config
     * @return {?}
     */
    function (config) {
        var _this = this;
        if (!this.isStarted) {
            this.set(this._config.value.min);
        }
        return timer(0, config.trickleSpeed).pipe(tap(function () { return _this.inc(); }));
    };
    /**
     * Completes then resets the progress
     * @param {?} config
     * @return {?}
     */
    NgProgressRef.prototype.onComplete = /**
     * Completes then resets the progress
     * @param {?} config
     * @return {?}
     */
    function (config) {
        var _this = this;
        return !this.isStarted ? of({}) : of({}).pipe(
        // Completes the progress
        tap(function () { return _this.setState({ value: 100 }); }), 
        // Hides the progress bar after a tiny delay
        delay(config.speed * 1.7), tap(function () { return _this.setState({ active: false }); }), 
        // Resets the progress state
        delay(config.speed), tap(function () { return _this.setState({ value: 0 }); }));
    };
    return NgProgressRef;
}());
export { NgProgressRef };
if (false) {
    /**
     * Stream that emits when progress state is changed
     * @type {?}
     */
    NgProgressRef.prototype._state;
    /** @type {?} */
    NgProgressRef.prototype.state;
    /**
     * Stream that emits when config is changed
     * @type {?}
     */
    NgProgressRef.prototype._config;
    /** @type {?} */
    NgProgressRef.prototype.config;
    /**
     * Stream that increments and updates progress state
     * @type {?}
     */
    NgProgressRef.prototype._trickling;
    /**
     * Stream that combines "_trickling" and "config" streams
     * @type {?}
     */
    NgProgressRef.prototype._worker;
    /** @type {?} */
    NgProgressRef.prototype.deleteInstance;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctcHJvZ3Jlc3MtcmVmLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG5neC1wcm9ncmVzc2Jhci9jb3JlLyIsInNvdXJjZXMiOlsibGliL25nLXByb2dyZXNzLXJlZi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUNBLE9BQU8sRUFBYyxPQUFPLEVBQUUsZUFBZSxFQUFFLEtBQUssRUFBRSxFQUFFLEVBQUUsYUFBYSxFQUFvQixZQUFZLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdEgsT0FBTyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxvQkFBb0IsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTFHLElBQUE7SUE2Q0UsdUJBQVksWUFBOEIsRUFBVSxjQUF3QjtRQUE1RSxpQkFVQztRQVZtRCxtQkFBYyxHQUFkLGNBQWMsQ0FBVTs7OzswQkFsQzlDLElBQUksT0FBTyxFQUFFOzs7O3VCQUdFLFlBQVksQ0FBQyxLQUFLO1FBZ0M3RCxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksZUFBZSxDQUFrQixFQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBQyxDQUFDLENBQUM7UUFDOUUsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLGVBQWUsQ0FBbUIsWUFBWSxDQUFDLENBQUM7UUFDbkUsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksRUFBRSxDQUFDO1FBQ3hDLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUV6QyxJQUFJLENBQUMsT0FBTyxHQUFHLGFBQWEsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQzlELFFBQVEsQ0FBQyxVQUFDLEVBQTRDO2dCQUE1QywwQkFBNEMsRUFBM0MsYUFBSyxF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LENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUk7O1FBRTNDLEdBQUcsQ0FBQyxjQUFNLE9BQUEsS0FBSSxDQUFDLFFBQVEsQ0FBQyxFQUFDLEtBQUssRUFBRSxHQUFHLEVBQUMsQ0FBQyxFQUEzQixDQUEyQixDQUFDOztRQUd0QyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssR0FBRyxHQUFHLENBQUMsRUFDekIsR0FBRyxDQUFDLGNBQU0sT0FBQSxLQUFJLENBQUMsUUFBUSxDQUFDLEVBQUMsTUFBTSxFQUFFLEtBQUssRUFBQyxDQUFDLEVBQTlCLENBQThCLENBQUM7O1FBR3pDLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQ25CLEdBQUcsQ0FBQyxjQUFNLE9BQUEsS0FBSSxDQUFDLFFBQVEsQ0FBQyxFQUFDLEtBQUssRUFBRSxDQUFDLEVBQUMsQ0FBQyxFQUF6QixDQUF5QixDQUFDLENBQ3JDLENBQUM7O3dCQWpLTjtJQW1LQyxDQUFBO0FBL0pELHlCQStKQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5nUHJvZ3Jlc3NTdGF0ZSwgTmdQcm9ncmVzc0NvbmZpZyB9IGZyb20gJy4vbmctcHJvZ3Jlc3MuaW50ZXJmYWNlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3ViamVjdCwgQmVoYXZpb3JTdWJqZWN0LCB0aW1lciwgb2YsIGNvbWJpbmVMYXRlc3QsIFN1YnNjcmlwdGlvbkxpa2UsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyB0YXAsIG1hcCwgc2tpcCwgZGVsYXksIGZpbHRlciwgZGVib3VuY2UsIHN3aXRjaE1hcCwgZGlzdGluY3RVbnRpbENoYW5nZWQgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5leHBvcnQgY2xhc3MgTmdQcm9ncmVzc1JlZiB7XHJcblxyXG4gIC8qKiBTdHJlYW0gdGhhdCBlbWl0cyB3aGVuIHByb2dyZXNzIHN0YXRlIGlzIGNoYW5nZWQgKi9cclxuICBwcml2YXRlIHJlYWRvbmx5IF9zdGF0ZTogQmVoYXZpb3JTdWJqZWN0PE5nUHJvZ3Jlc3NTdGF0ZT47XHJcbiAgc3RhdGU6IE9ic2VydmFibGU8TmdQcm9ncmVzc1N0YXRlPjtcclxuXHJcbiAgLyoqIFN0cmVhbSB0aGF0IGVtaXRzIHdoZW4gY29uZmlnIGlzIGNoYW5nZWQgKi9cclxuICBwcml2YXRlIHJlYWRvbmx5IF9jb25maWc6IEJlaGF2aW9yU3ViamVjdDxOZ1Byb2dyZXNzQ29uZmlnPjtcclxuICBjb25maWc6IE9ic2VydmFibGU8TmdQcm9ncmVzc1N0YXRlPjtcclxuXHJcbiAgLyoqIFN0cmVhbSB0aGF0IGluY3JlbWVudHMgYW5kIHVwZGF0ZXMgcHJvZ3Jlc3Mgc3RhdGUgKi9cclxuICBwcml2YXRlIHJlYWRvbmx5IF90cmlja2xpbmcgPSBuZXcgU3ViamVjdCgpO1xyXG5cclxuICAvKiogU3RyZWFtIHRoYXQgY29tYmluZXMgXCJfdHJpY2tsaW5nXCIgYW5kIFwiY29uZmlnXCIgc3RyZWFtcyAqL1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgX3dvcmtlcjogU3Vic2NyaXB0aW9uTGlrZSA9IFN1YnNjcmlwdGlvbi5FTVBUWTtcclxuXHJcbiAgLyoqIEdldCBjdXJyZW50IHByb2dyZXNzIHN0YXRlICovXHJcbiAgcHJpdmF0ZSBnZXQgY3VyclN0YXRlKCk6IE5nUHJvZ3Jlc3NTdGF0ZSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc3RhdGUudmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKiogQ2hlY2sgaWYgcHJvZ3Jlc3MgaGFzIHN0YXJ0ZWQgKi9cclxuICBnZXQgaXNTdGFydGVkKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMuY3VyclN0YXRlLmFjdGl2ZTtcclxuICB9XHJcblxyXG4gIC8qKiBQcm9ncmVzcyBzdGFydCBldmVudCAqL1xyXG4gIGdldCBzdGFydGVkKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlLnBpcGUoXHJcbiAgICAgIG1hcCgoc3RhdGU6IE5nUHJvZ3Jlc3NTdGF0ZSkgPT4gc3RhdGUuYWN0aXZlKSxcclxuICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcclxuICAgICAgZmlsdGVyKGFjdGl2ZSA9PiBhY3RpdmUpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqIFByb2dyZXNzIGVuZGVkIGV2ZW50ICovXHJcbiAgZ2V0IGNvbXBsZXRlZCgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcclxuICAgIHJldHVybiB0aGlzLl9zdGF0ZS5waXBlKFxyXG4gICAgICBtYXAoKHN0YXRlOiBOZ1Byb2dyZXNzU3RhdGUpID0+IHN0YXRlLmFjdGl2ZSksXHJcbiAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXHJcbiAgICAgIGZpbHRlcihhY3RpdmUgPT4gIWFjdGl2ZSksXHJcbiAgICAgIHNraXAoMSlcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3RvcihjdXN0b21Db25maWc6IE5nUHJvZ3Jlc3NDb25maWcsIHByaXZhdGUgZGVsZXRlSW5zdGFuY2U6IEZ1bmN0aW9uKSB7XHJcbiAgICB0aGlzLl9zdGF0ZSA9IG5ldyBCZWhhdmlvclN1YmplY3Q8TmdQcm9ncmVzc1N0YXRlPih7YWN0aXZlOiBmYWxzZSwgdmFsdWU6IDB9KTtcclxuICAgIHRoaXMuX2NvbmZpZyA9IG5ldyBCZWhhdmlvclN1YmplY3Q8TmdQcm9ncmVzc0NvbmZpZz4oY3VzdG9tQ29uZmlnKTtcclxuICAgIHRoaXMuc3RhdGUgPSB0aGlzLl9zdGF0ZS5hc09ic2VydmFibGUoKTtcclxuICAgIHRoaXMuY29uZmlnID0gdGhpcy5fc3RhdGUuYXNPYnNlcnZhYmxlKCk7XHJcblxyXG4gICAgdGhpcy5fd29ya2VyID0gY29tYmluZUxhdGVzdCh0aGlzLl90cmlja2xpbmcsIHRoaXMuX2NvbmZpZykucGlwZShcclxuICAgICAgZGVib3VuY2UoKFtzdGFydCwgY29uZmlnXTogW2Jvb2xlYW4sIE5nUHJvZ3Jlc3NDb25maWddKSA9PiB0aW1lcihzdGFydCA/IGNvbmZpZy5kZWJvdW5jZVRpbWUgOiAwKSksXHJcbiAgICAgIHN3aXRjaE1hcCgoW3N0YXJ0LCBjb25maWddOiBbYm9vbGVhbiwgTmdQcm9ncmVzc0NvbmZpZ10pID0+IHN0YXJ0ID8gdGhpcy5vblRyaWNrbGluZyhjb25maWcpIDogdGhpcy5vbkNvbXBsZXRlKGNvbmZpZykpXHJcbiAgICApLnN1YnNjcmliZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQgdGhlIHByb2dyZXNzXHJcbiAgICovXHJcbiAgc3RhcnQoKSB7XHJcbiAgICB0aGlzLl90cmlja2xpbmcubmV4dCh0cnVlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXBsZXRlIHRoZSBwcm9ncmVzc1xyXG4gICAqL1xyXG4gIGNvbXBsZXRlKCkge1xyXG4gICAgdGhpcy5fdHJpY2tsaW5nLm5leHQoZmFsc2UpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5jcmVtZW50IHRoZSBwcm9ncmVzc1xyXG4gICAqIEBwYXJhbSBhbW91bnRcclxuICAgKi9cclxuICBpbmMoYW1vdW50PzogbnVtYmVyKSB7XHJcbiAgICBjb25zdCBuID0gdGhpcy5jdXJyU3RhdGUudmFsdWU7XHJcbiAgICBpZiAoIXRoaXMuaXNTdGFydGVkKSB7XHJcbiAgICAgIHRoaXMuc3RhcnQoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmICh0eXBlb2YgYW1vdW50ICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgIGFtb3VudCA9IHRoaXMuX2NvbmZpZy52YWx1ZS50cmlja2xlRnVuYyhuKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnNldChuICsgYW1vdW50KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgcHJvZ3Jlc3NcclxuICAgKiBAcGFyYW0gblxyXG4gICAqL1xyXG4gIHNldChuOiBudW1iZXIpIHtcclxuICAgIHRoaXMuc2V0U3RhdGUoe3ZhbHVlOiB0aGlzLmNsYW1wKG4pLCBhY3RpdmU6IHRydWV9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCBjb25maWdcclxuICAgKiBAcGFyYW0gY29uZmlnXHJcbiAgICovXHJcbiAgc2V0Q29uZmlnKGNvbmZpZzogTmdQcm9ncmVzc0NvbmZpZykge1xyXG4gICAgdGhpcy5fY29uZmlnLm5leHQoey4uLnRoaXMuX2NvbmZpZy52YWx1ZSwgLi4uY29uZmlnfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXN0cm95IHByb2dyZXNzIHJlZmVyZW5jZVxyXG4gICAqL1xyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLl93b3JrZXIudW5zdWJzY3JpYmUoKTtcclxuICAgIHRoaXMuX3RyaWNrbGluZy5jb21wbGV0ZSgpO1xyXG4gICAgdGhpcy5fc3RhdGUuY29tcGxldGUoKTtcclxuICAgIHRoaXMuX2NvbmZpZy5jb21wbGV0ZSgpO1xyXG4gICAgdGhpcy5kZWxldGVJbnN0YW5jZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHByb2dyZXNzIHN0YXRlXHJcbiAgICogQHBhcmFtIHN0YXRlXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBzZXRTdGF0ZShzdGF0ZTogTmdQcm9ncmVzc1N0YXRlKSB7XHJcbiAgICB0aGlzLl9zdGF0ZS5uZXh0KHsuLi50aGlzLmN1cnJTdGF0ZSwgLi4uc3RhdGV9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsYW1wcyBhIHZhbHVlIHRvIGJlIGJldHdlZW4gbWluIGFuZCBtYXhcclxuICAgKiBAcGFyYW0gblxyXG4gICAqL1xyXG4gIHByaXZhdGUgY2xhbXAobjogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiBNYXRoLm1heCh0aGlzLl9jb25maWcudmFsdWUubWluLCBNYXRoLm1pbih0aGlzLl9jb25maWcudmFsdWUubWF4LCBuKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBLZWVwcyBpbmNyZW1lbnRpbmcgdGhlIHByb2dyZXNzXHJcbiAgICogQHBhcmFtIGNvbmZpZ1xyXG4gICAqL1xyXG4gIHByaXZhdGUgb25Ucmlja2xpbmcoY29uZmlnOiBOZ1Byb2dyZXNzQ29uZmlnKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcclxuICAgIGlmICghdGhpcy5pc1N0YXJ0ZWQpIHtcclxuICAgICAgdGhpcy5zZXQodGhpcy5fY29uZmlnLnZhbHVlLm1pbik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGltZXIoMCwgY29uZmlnLnRyaWNrbGVTcGVlZCkucGlwZSh0YXAoKCkgPT4gdGhpcy5pbmMoKSkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29tcGxldGVzIHRoZW4gcmVzZXRzIHRoZSBwcm9ncmVzc1xyXG4gICAqIEBwYXJhbSBjb25maWdcclxuICAgKi9cclxuICBwcml2YXRlIG9uQ29tcGxldGUoY29uZmlnOiBOZ1Byb2dyZXNzQ29uZmlnKTogT2JzZXJ2YWJsZTxhbnk+IHtcclxuICAgIHJldHVybiAhdGhpcy5pc1N0YXJ0ZWQgPyBvZih7fSkgOiBvZih7fSkucGlwZShcclxuICAgICAgLy8gQ29tcGxldGVzIHRoZSBwcm9ncmVzc1xyXG4gICAgICB0YXAoKCkgPT4gdGhpcy5zZXRTdGF0ZSh7dmFsdWU6IDEwMH0pKSxcclxuXHJcbiAgICAgIC8vIEhpZGVzIHRoZSBwcm9ncmVzcyBiYXIgYWZ0ZXIgYSB0aW55IGRlbGF5XHJcbiAgICAgIGRlbGF5KGNvbmZpZy5zcGVlZCAqIDEuNyksXHJcbiAgICAgIHRhcCgoKSA9PiB0aGlzLnNldFN0YXRlKHthY3RpdmU6IGZhbHNlfSkpLFxyXG5cclxuICAgICAgLy8gUmVzZXRzIHRoZSBwcm9ncmVzcyBzdGF0ZVxyXG4gICAgICBkZWxheShjb25maWcuc3BlZWQpLFxyXG4gICAgICB0YXAoKCkgPT4gdGhpcy5zZXRTdGF0ZSh7dmFsdWU6IDB9KSlcclxuICAgICk7XHJcbiAgfVxyXG59XHJcbiJdfQ==