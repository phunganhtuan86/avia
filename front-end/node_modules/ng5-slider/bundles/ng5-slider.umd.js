(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('detect-passive-events'), require('@angular/forms'), require('@angular/common')) :
	typeof define === 'function' && define.amd ? define('ng5-slider', ['exports', '@angular/core', 'detect-passive-events', '@angular/forms', '@angular/common'], factory) :
	(factory((global['ng5-slider'] = {}),global.ng.core,global.detectPassiveEvents,global.ng.forms,global.ng.common));
}(this, (function (exports,core,detectPassiveEvents,forms,common) { 'use strict';

detectPassiveEvents = detectPassiveEvents && detectPassiveEvents.hasOwnProperty('default') ? detectPassiveEvents['default'] : detectPassiveEvents;

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.
See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */
var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}








function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

var PointerType = {
    Min: 0,
    Max: 1,
};
PointerType[PointerType.Min] = "Min";
PointerType[PointerType.Max] = "Max";
var LabelType = {
    Low: 0,
    High: 1,
    Floor: 2,
    Ceil: 3,
    TickValue: 4,
};
LabelType[LabelType.Low] = "Low";
LabelType[LabelType.High] = "High";
LabelType[LabelType.Floor] = "Floor";
LabelType[LabelType.Ceil] = "Ceil";
LabelType[LabelType.TickValue] = "TickValue";
var Options = /** @class */ (function () {
    function Options() {
        this.floor = 0;
        this.ceil = null;
        this.step = 1;
        this.minRange = null;
        this.maxRange = null;
        this.pushRange = false;
        this.minLimit = null;
        this.maxLimit = null;
        this.translate = null;
        this.combineLabels = null;
        this.getLegend = null;
        this.stepsArray = null;
        this.bindIndexForStepsArray = false;
        this.draggableRange = false;
        this.draggableRangeOnly = false;
        this.showSelectionBar = false;
        this.showSelectionBarEnd = false;
        this.showSelectionBarFromValue = null;
        this.showOuterSelectionBars = false;
        this.hidePointerLabels = false;
        this.hideLimitLabels = false;
        this.autoHideLimitLabels = true;
        this.readOnly = false;
        this.disabled = false;
        this.interval = 350;
        this.showTicks = false;
        this.showTicksValues = false;
        this.tickStep = null;
        this.tickValueStep = 1;
        this.ticksArray = null;
        this.ticksTooltip = null;
        this.ticksValuesTooltip = null;
        this.vertical = false;
        this.getSelectionBarColor = null;
        this.getTickColor = null;
        this.getPointerColor = null;
        this.keyboardSupport = true;
        this.scale = 1;
        this.enforceStep = true;
        this.enforceRange = false;
        this.noSwitching = false;
        this.onlyBindHandles = false;
        this.rightToLeft = false;
        this.reversedControls = false;
        this.boundPointerLabels = true;
        this.logScale = false;
        this.customValueToPosition = null;
        this.customPositionToValue = null;
        this.precisionLimit = 12;
        this.selectionBarGradient = null;
        this.ariaLabel = null;
        this.ariaLabelledBy = null;
        this.ariaLabelHigh = null;
        this.ariaLabelledByHigh = null;
    }
    return Options;
}());
var ChangeContext = /** @class */ (function () {
    function ChangeContext() {
    }
    return ChangeContext;
}());
var ValueHelper = /** @class */ (function () {
    function ValueHelper() {
    }
    ValueHelper.linearValueToPosition = function (val, minVal, maxVal) {
        var range = maxVal - minVal;
        return (val - minVal) / range;
    };
    ValueHelper.logValueToPosition = function (val, minVal, maxVal) {
        val = Math.log(val);
        minVal = Math.log(minVal);
        maxVal = Math.log(maxVal);
        var range = maxVal - minVal;
        return (val - minVal) / range;
    };
    ValueHelper.linearPositionToValue = function (percent, minVal, maxVal) {
        return percent * (maxVal - minVal) + minVal;
    };
    ValueHelper.logPositionToValue = function (percent, minVal, maxVal) {
        minVal = Math.log(minVal);
        maxVal = Math.log(maxVal);
        var value = percent * (maxVal - minVal) + minVal;
        return Math.exp(value);
    };
    ValueHelper.findStepIndex = function (modelValue, stepsArray) {
        var differences = stepsArray.map(function (step) { return Math.abs(modelValue - step.value); });
        var minDifferenceIndex = 0;
        for (var index = 0; index < stepsArray.length; index++) {
            if (differences[index] !== differences[minDifferenceIndex] && differences[index] < differences[minDifferenceIndex]) {
                minDifferenceIndex = index;
            }
        }
        return minDifferenceIndex;
    };
    return ValueHelper;
}());
var JqLiteWrapper = /** @class */ (function () {
    function JqLiteWrapper(elemRef, renderer) {
        this.elemRef = elemRef;
        this.renderer = renderer;
        this.eventListeners = {};
    }
    JqLiteWrapper.prototype.addClass = function (clazz) {
        this.renderer.addClass(this.elemRef.nativeElement, clazz);
    };
    JqLiteWrapper.prototype.removeClass = function (clazz) {
        this.renderer.removeClass(this.elemRef.nativeElement, clazz);
    };
    JqLiteWrapper.prototype.hasClass = function (clazz) {
        return this.elemRef.nativeElement.classList.contains(clazz);
    };
    JqLiteWrapper.prototype.html = function (html) {
        this.elemRef.nativeElement.innerHTML = html;
    };
    JqLiteWrapper.prototype.css = function (style, value) {
        if (value !== '') {
            this.renderer.setStyle(this.elemRef.nativeElement, style, value);
        }
        else {
            this.renderer.removeStyle(this.elemRef.nativeElement, style);
        }
    };
    JqLiteWrapper.prototype.attr = function (attr, value) {
        if (value !== null) {
            this.renderer.setAttribute(this.elemRef.nativeElement, attr, value);
        }
        else {
            this.renderer.removeAttribute(this.elemRef.nativeElement, attr);
        }
    };
    JqLiteWrapper.prototype.getBoundingClientRect = function () {
        return this.elemRef.nativeElement.getBoundingClientRect();
    };
    JqLiteWrapper.prototype.focus = function () {
        this.elemRef.nativeElement.focus();
    };
    JqLiteWrapper.prototype.on = function (eventName, callback) {
        if (!this.eventListeners.hasOwnProperty(eventName)) {
            this.eventListeners[eventName] = [];
        }
        var unsubscribe = this.renderer.listen(this.elemRef.nativeElement, eventName, callback);
        this.eventListeners[eventName].push(unsubscribe);
    };
    JqLiteWrapper.prototype.onPassive = function (eventName, callback) {
        var _this = this;
        if (!detectPassiveEvents.hasSupport) {
            this.on(eventName, callback);
            return;
        }
        if (!this.eventListeners.hasOwnProperty(eventName)) {
            this.eventListeners[eventName] = [];
        }
        this.elemRef.nativeElement.addEventListener(eventName, callback, { passive: true, capture: false });
        var unsubscribe = function () {
            _this.elemRef.nativeElement.removeEventListener(eventName, callback, { passive: true, capture: false });
        };
        this.eventListeners[eventName].push(unsubscribe);
    };
    JqLiteWrapper.prototype.off = function (eventName) {
        if (eventName) {
            if (this.eventListeners.hasOwnProperty(eventName)) {
                try {
                    for (var _a = __values(this.eventListeners[eventName]), _b = _a.next(); !_b.done; _b = _a.next()) {
                        var unsubscribe = _b.value;
                        unsubscribe();
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                delete this.eventListeners[eventName];
            }
        }
        else {
            try {
                for (var _d = __values(Object.keys(this.eventListeners)), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var eName = _e.value;
                    this.off(eName);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_f = _d.return)) _f.call(_d);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        var e_1, _c, e_2, _f;
    };
    return JqLiteWrapper;
}());
var ThrottledFunc = /** @class */ (function () {
    function ThrottledFunc(func, wait) {
        this.previous = 0;
        this.timeout = null;
        this.func = func;
        this.wait = wait;
    }
    ThrottledFunc.prototype.call = function () {
        var _this = this;
        var now = this.getTime();
        var remaining = this.wait - (now - this.previous);
        if (remaining <= 0) {
            clearTimeout(this.timeout);
            this.timeout = null;
            this.previous = now;
            this.func();
        }
        else if (this.timeout === null) {
            this.timeout = setTimeout(function () { return _this.callLater(); }, remaining);
        }
    };
    ThrottledFunc.prototype.getTime = function () {
        return Date.now();
    };
    ThrottledFunc.prototype.callLater = function () {
        this.previous = this.getTime();
        this.timeout = null;
        this.func();
    };
    return ThrottledFunc;
}());
var CompatibilityHelper = /** @class */ (function () {
    function CompatibilityHelper() {
    }
    CompatibilityHelper.isTouchEvent = function (event) {
        if (((window)).TouchEvent !== undefined) {
            return event instanceof TouchEvent;
        }
        return event.touches !== undefined;
    };
    return CompatibilityHelper;
}());
var MathHelper = /** @class */ (function () {
    function MathHelper() {
    }
    MathHelper.roundToPrecisionLimit = function (value, precisionLimit) {
        return +(value.toPrecision(precisionLimit));
    };
    MathHelper.clampToRange = function (value, floor, ceil) {
        return Math.min(Math.max(value, floor), ceil);
    };
    return MathHelper;
}());
var Tick = /** @class */ (function () {
    function Tick() {
    }
    return Tick;
}());
var Dragging = /** @class */ (function () {
    function Dragging() {
        this.active = false;
        this.value = 0;
        this.difference = 0;
        this.position = 0;
        this.lowLimit = 0;
        this.highLimit = 0;
    }
    return Dragging;
}());
var HandleType = {
    Low: 0,
    High: 1,
};
HandleType[HandleType.Low] = "Low";
HandleType[HandleType.High] = "High";
var HandleLabelType = {
    Min: 0,
    Max: 1,
};
HandleLabelType[HandleLabelType.Min] = "Min";
HandleLabelType[HandleLabelType.Max] = "Max";
var SliderElement = /** @class */ (function (_super) {
    __extends(SliderElement, _super);
    function SliderElement(elemRef, renderer) {
        var _this = _super.call(this, elemRef, renderer) || this;
        _this.position = 0;
        _this.alwaysHide = false;
        return _this;
    }
    return SliderElement;
}(JqLiteWrapper));
var RightOutSelDirective = /** @class */ (function (_super) {
    __extends(RightOutSelDirective, _super);
    function RightOutSelDirective(elemRef, renderer) {
        return _super.call(this, elemRef, renderer) || this;
    }
    return RightOutSelDirective;
}(SliderElement));
RightOutSelDirective.decorators = [
    { type: core.Directive, args: [{ selector: '[ng5SliderRightOutSelElem]' },] },
];
RightOutSelDirective.ctorParameters = function () { return [
    { type: core.ElementRef, },
    { type: core.Renderer2, },
]; };
var LeftOutSelDirective = /** @class */ (function (_super) {
    __extends(LeftOutSelDirective, _super);
    function LeftOutSelDirective(elemRef, renderer) {
        return _super.call(this, elemRef, renderer) || this;
    }
    return LeftOutSelDirective;
}(SliderElement));
LeftOutSelDirective.decorators = [
    { type: core.Directive, args: [{ selector: '[ng5SliderLeftOutSelElem]' },] },
];
LeftOutSelDirective.ctorParameters = function () { return [
    { type: core.ElementRef, },
    { type: core.Renderer2, },
]; };
var FullBarDirective = /** @class */ (function (_super) {
    __extends(FullBarDirective, _super);
    function FullBarDirective(elemRef, renderer) {
        return _super.call(this, elemRef, renderer) || this;
    }
    return FullBarDirective;
}(SliderElement));
FullBarDirective.decorators = [
    { type: core.Directive, args: [{ selector: '[ng5SliderFullBarElem]' },] },
];
FullBarDirective.ctorParameters = function () { return [
    { type: core.ElementRef, },
    { type: core.Renderer2, },
]; };
var SelBarDirective = /** @class */ (function (_super) {
    __extends(SelBarDirective, _super);
    function SelBarDirective(elemRef, renderer) {
        return _super.call(this, elemRef, renderer) || this;
    }
    return SelBarDirective;
}(SliderElement));
SelBarDirective.decorators = [
    { type: core.Directive, args: [{ selector: '[ng5SliderSelBarElem]' },] },
];
SelBarDirective.ctorParameters = function () { return [
    { type: core.ElementRef, },
    { type: core.Renderer2, },
]; };
var MinHDirective = /** @class */ (function (_super) {
    __extends(MinHDirective, _super);
    function MinHDirective(elemRef, renderer) {
        return _super.call(this, elemRef, renderer) || this;
    }
    return MinHDirective;
}(SliderElement));
MinHDirective.decorators = [
    { type: core.Directive, args: [{ selector: '[ng5SliderMinHElem]' },] },
];
MinHDirective.ctorParameters = function () { return [
    { type: core.ElementRef, },
    { type: core.Renderer2, },
]; };
var MaxHDirective = /** @class */ (function (_super) {
    __extends(MaxHDirective, _super);
    function MaxHDirective(elemRef, renderer) {
        return _super.call(this, elemRef, renderer) || this;
    }
    return MaxHDirective;
}(SliderElement));
MaxHDirective.decorators = [
    { type: core.Directive, args: [{ selector: '[ng5SliderMaxHElem]' },] },
];
MaxHDirective.ctorParameters = function () { return [
    { type: core.ElementRef, },
    { type: core.Renderer2, },
]; };
var FlrLabDirective = /** @class */ (function (_super) {
    __extends(FlrLabDirective, _super);
    function FlrLabDirective(elemRef, renderer) {
        return _super.call(this, elemRef, renderer) || this;
    }
    return FlrLabDirective;
}(SliderElement));
FlrLabDirective.decorators = [
    { type: core.Directive, args: [{ selector: '[ng5SliderFlrLabElem]' },] },
];
FlrLabDirective.ctorParameters = function () { return [
    { type: core.ElementRef, },
    { type: core.Renderer2, },
]; };
var CeilLabDirective = /** @class */ (function (_super) {
    __extends(CeilLabDirective, _super);
    function CeilLabDirective(elemRef, renderer) {
        return _super.call(this, elemRef, renderer) || this;
    }
    return CeilLabDirective;
}(SliderElement));
CeilLabDirective.decorators = [
    { type: core.Directive, args: [{ selector: '[ng5SliderCeilLabElem]' },] },
];
CeilLabDirective.ctorParameters = function () { return [
    { type: core.ElementRef, },
    { type: core.Renderer2, },
]; };
var MinLabDirective = /** @class */ (function (_super) {
    __extends(MinLabDirective, _super);
    function MinLabDirective(elemRef, renderer) {
        return _super.call(this, elemRef, renderer) || this;
    }
    return MinLabDirective;
}(SliderElement));
MinLabDirective.decorators = [
    { type: core.Directive, args: [{ selector: '[ng5SliderMinLabElem]' },] },
];
MinLabDirective.ctorParameters = function () { return [
    { type: core.ElementRef, },
    { type: core.Renderer2, },
]; };
var MaxLabDirective = /** @class */ (function (_super) {
    __extends(MaxLabDirective, _super);
    function MaxLabDirective(elemRef, renderer) {
        return _super.call(this, elemRef, renderer) || this;
    }
    return MaxLabDirective;
}(SliderElement));
MaxLabDirective.decorators = [
    { type: core.Directive, args: [{ selector: '[ng5SliderMaxLabElem]' },] },
];
MaxLabDirective.ctorParameters = function () { return [
    { type: core.ElementRef, },
    { type: core.Renderer2, },
]; };
var CmbLabDirective = /** @class */ (function (_super) {
    __extends(CmbLabDirective, _super);
    function CmbLabDirective(elemRef, renderer) {
        return _super.call(this, elemRef, renderer) || this;
    }
    return CmbLabDirective;
}(SliderElement));
CmbLabDirective.decorators = [
    { type: core.Directive, args: [{ selector: '[ng5SliderCmbLabElem]' },] },
];
CmbLabDirective.ctorParameters = function () { return [
    { type: core.ElementRef, },
    { type: core.Renderer2, },
]; };
var TicksDirective = /** @class */ (function (_super) {
    __extends(TicksDirective, _super);
    function TicksDirective(elemRef, renderer) {
        return _super.call(this, elemRef, renderer) || this;
    }
    return TicksDirective;
}(SliderElement));
TicksDirective.decorators = [
    { type: core.Directive, args: [{ selector: '[ng5SliderTicksElem]' },] },
];
TicksDirective.ctorParameters = function () { return [
    { type: core.ElementRef, },
    { type: core.Renderer2, },
]; };
var NG5_SLIDER_CONTROL_VALUE_ACCESSOR = {
    provide: forms.NG_VALUE_ACCESSOR,
    useExisting: core.forwardRef(function () { return SliderComponent; }),
    multi: true,
};
var SliderComponent = /** @class */ (function () {
    function SliderComponent(renderer, elementRef, changeDetectionRef) {
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.changeDetectionRef = changeDetectionRef;
        this.valueChange = new core.EventEmitter();
        this.highValueChange = new core.EventEmitter();
        this.userChangeStart = new core.EventEmitter();
        this.userChange = new core.EventEmitter();
        this.userChangeEnd = new core.EventEmitter();
        this._options = new Options();
        this.viewOptions = new Options();
        this.barStyle = {};
        this.minPointerStyle = {};
        this.maxPointerStyle = {};
        this.showTicks = false;
        this.ticks = [];
        this.sliderElementVerticalClass = false;
        this.sliderElementDisabledAttr = null;
        this.sliderElementPosition = 0;
        this.dragging = new Dragging();
        this.handleHalfDim = 0;
        this.maxPos = 0;
        this.precisionLimit = 12;
        this.step = 1;
        this.tracking = null;
        this.minValue = 0;
        this.maxValue = 0;
        this.valueRange = 0;
        this.intermediateTicks = false;
        this.initHasRun = false;
        this.firstKeyDown = false;
        this.internalChange = false;
        this.cmbLabelShown = false;
        this.currentFocusElement = null;
        this.onMoveUnsubscribe = null;
        this.onEndUnsubscribe = null;
        this.onTouchedCallback = null;
        this.onChangeCallback = null;
    }
    Object.defineProperty(SliderComponent.prototype, "value", {
        get: function () {
            return this._value;
        },
        set: function (newValue) {
            var oldValue = this._value;
            this._value = +newValue;
            this.onChangeValue(oldValue, newValue);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "highValue", {
        get: function () {
            return this._highValue;
        },
        set: function (newHighValue) {
            var oldHighValue = this._highValue;
            this._highValue = +newHighValue;
            this.onChangeHighValue(oldHighValue, newHighValue);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "options", {
        get: function () {
            return this._options;
        },
        set: function (newOptions) {
            var oldOptions = this._options;
            this._options = newOptions;
            this.onChangeOptions(oldOptions, newOptions);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "manualRefresh", {
        set: function (manualRefresh) {
            var _this = this;
            this.unsubscribeManualRefresh();
            this.manualRefreshSubscription = manualRefresh.subscribe(function () {
                setTimeout(function () { return _this.calcViewDimensions(); });
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "range", {
        get: function () {
            return this.value !== undefined && this.highValue !== undefined;
        },
        enumerable: true,
        configurable: true
    });
    SliderComponent.prototype.ngOnInit = function () {
        this.viewOptions = new Options();
        Object.assign(this.viewOptions, this.options);
        this.setDisabledStateAttr();
        this.setVerticalClass();
    };
    SliderComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        this.thrOnLowHandleChange = new ThrottledFunc(function () { _this.onLowHandleChange(); }, this.viewOptions.interval);
        this.thrOnHighHandleChange = new ThrottledFunc(function () { _this.onHighHandleChange(); }, this.viewOptions.interval);
        this.applyOptions();
        this.syncLowValue();
        if (this.range) {
            this.syncHighValue();
        }
        this.manageElementsStyle();
        this.setDisabledStateAttr();
        this.calcViewDimensions();
        this.setMinAndMax();
        this.addAccessibility();
        this.updateCeilLab();
        this.updateFloorLab();
        this.initHandles();
        this.manageEventsBindings();
        this.initHasRun = true;
        if (this.value !== this.viewLowValue || (this.range && this.highValue !== this.viewHighValue)) {
            setTimeout(function () { return _this.applyModel(false); });
        }
        this.changeDetectionRef.detectChanges();
    };
    SliderComponent.prototype.onChangeOptions = function (oldValue, newValue) {
        if (!this.initHasRun || newValue === oldValue) {
            return;
        }
        this.applyOptions();
        this.syncLowValue();
        if (this.range) {
            this.syncHighValue();
        }
        this.resetSlider();
    };
    SliderComponent.prototype.onChangeValue = function (oldValue, newValue) {
        if (!this.initHasRun || this.internalChange || newValue === oldValue) {
            return;
        }
        this.thrOnLowHandleChange.call();
    };
    SliderComponent.prototype.onChangeHighValue = function (oldValue, newValue) {
        if (!this.initHasRun || this.internalChange || newValue === oldValue) {
            return;
        }
        if (newValue != null) {
            this.thrOnHighHandleChange.call();
        }
        if ((this.range && newValue == null) ||
            (!this.range && newValue != null)) {
            this.applyOptions();
            this.resetSlider();
        }
    };
    SliderComponent.prototype.onResize = function (event) {
        this.calcViewDimensions();
    };
    SliderComponent.prototype.ngOnDestroy = function () {
        this.unsubscribeManualRefresh();
        this.unbindEvents();
        this.currentFocusElement = null;
    };
    SliderComponent.prototype.writeValue = function (obj) {
        if (obj instanceof Array) {
            this.value = obj[0];
            this.highValue = obj[1];
        }
        else {
            this.value = obj;
        }
    };
    SliderComponent.prototype.registerOnChange = function (onChangeCallback) {
        this.onChangeCallback = onChangeCallback;
    };
    SliderComponent.prototype.registerOnTouched = function (onTouchedCallback) {
        this.onTouchedCallback = onTouchedCallback;
    };
    SliderComponent.prototype.setDisabledState = function (isDisabled) {
        if (this.viewOptions) {
            this.viewOptions.disabled = isDisabled;
            this.setDisabledStateAttr();
        }
    };
    SliderComponent.prototype.unsubscribeManualRefresh = function () {
        if (this.manualRefreshSubscription) {
            this.manualRefreshSubscription.unsubscribe();
            this.manualRefreshSubscription = null;
        }
    };
    SliderComponent.prototype.getCurrentTrackingValue = function () {
        if (this.tracking === null) {
            return null;
        }
        return this.tracking === HandleType.Low ? this.viewLowValue : this.viewHighValue;
    };
    SliderComponent.prototype.syncLowValue = function () {
        if (this.viewOptions.stepsArray) {
            if (!this.viewOptions.bindIndexForStepsArray) {
                this.viewLowValue = ValueHelper.findStepIndex(this.value, this.viewOptions.stepsArray);
            }
            else {
                this.viewLowValue = this.value;
            }
        }
        else {
            this.viewLowValue = this.value;
        }
    };
    SliderComponent.prototype.syncHighValue = function () {
        if (this.viewOptions.stepsArray) {
            if (!this.viewOptions.bindIndexForStepsArray) {
                this.viewHighValue = ValueHelper.findStepIndex(this.highValue, this.viewOptions.stepsArray);
            }
            else {
                this.viewHighValue = this.highValue;
            }
        }
        else {
            this.viewHighValue = this.highValue;
        }
    };
    SliderComponent.prototype.getStepValue = function (sliderValue) {
        var step = this.viewOptions.stepsArray[sliderValue];
        return step.value;
    };
    SliderComponent.prototype.applyLowValue = function () {
        this.internalChange = true;
        if (this.viewOptions.stepsArray) {
            if (!this.viewOptions.bindIndexForStepsArray) {
                this.value = this.getStepValue(this.viewLowValue);
            }
            else {
                this.value = this.viewLowValue;
            }
        }
        else {
            this.value = this.viewLowValue;
        }
        this.internalChange = false;
    };
    SliderComponent.prototype.applyHighValue = function () {
        this.internalChange = true;
        if (this.viewOptions.stepsArray) {
            if (!this.viewOptions.bindIndexForStepsArray) {
                this.highValue = this.getStepValue(this.viewHighValue);
            }
            else {
                this.highValue = this.viewHighValue;
            }
        }
        else {
            this.highValue = this.viewHighValue;
        }
        this.internalChange = false;
    };
    SliderComponent.prototype.onLowHandleChange = function () {
        this.normaliseLowValue();
        if (this.range) {
            this.normaliseRange(PointerType.Min);
        }
        this.syncLowValue();
        if (this.range) {
            this.syncHighValue();
        }
        this.setMinAndMax();
        this.updateLowHandle(this.valueToPosition(this.viewLowValue));
        this.updateSelectionBar();
        this.updateTicksScale();
        this.updateAriaAttributes();
        if (this.range) {
            this.updateCmbLabel();
        }
    };
    SliderComponent.prototype.onHighHandleChange = function () {
        this.normaliseHighValue();
        this.normaliseRange(PointerType.Max);
        this.syncLowValue();
        this.syncHighValue();
        this.setMinAndMax();
        this.updateHighHandle(this.valueToPosition(this.viewHighValue));
        this.updateSelectionBar();
        this.updateTicksScale();
        this.updateCmbLabel();
        this.updateAriaAttributes();
    };
    SliderComponent.prototype.normaliseLowValue = function () {
        var _this = this;
        if (this.viewOptions.stepsArray) {
            return;
        }
        var normalisedValue = MathHelper.clampToRange(this.value, this.viewOptions.floor, this.viewOptions.ceil);
        if (this.value !== normalisedValue) {
            this.internalChange = true;
            this.value = normalisedValue;
            this.internalChange = false;
            setTimeout(function () { return _this.applyModel(false); });
        }
    };
    SliderComponent.prototype.normaliseHighValue = function () {
        var _this = this;
        if (this.viewOptions.stepsArray) {
            return;
        }
        var normalisedHighValue = MathHelper.clampToRange(this.highValue, this.viewOptions.floor, this.viewOptions.ceil);
        if (this.highValue !== normalisedHighValue) {
            this.internalChange = true;
            this.highValue = normalisedHighValue;
            this.internalChange = false;
            setTimeout(function () { return _this.applyModel(false); });
        }
    };
    SliderComponent.prototype.normaliseRange = function (changedPointer) {
        var _this = this;
        if (this.viewOptions.stepsArray) {
            return;
        }
        if (this.range && this.value > this.highValue) {
            if (this.viewOptions.noSwitching) {
                this.internalChange = true;
                if (changedPointer === PointerType.Max) {
                    this.highValue = this.value;
                }
                else if (changedPointer === PointerType.Min) {
                    this.value = this.highValue;
                }
                this.internalChange = false;
                setTimeout(function () { return _this.applyModel(false); });
            }
            else {
                this.internalChange = true;
                var tempValue = this.value;
                this.value = this.highValue;
                this.highValue = tempValue;
                this.internalChange = false;
                if (changedPointer === PointerType.Max) {
                    setTimeout(function () { return _this.thrOnLowHandleChange.call(); });
                }
                else if (changedPointer === PointerType.Min) {
                    setTimeout(function () { return _this.thrOnHighHandleChange.call(); });
                }
                setTimeout(function () { return _this.applyModel(false); });
            }
        }
    };
    SliderComponent.prototype.applyOptions = function () {
        this.viewOptions = new Options();
        Object.assign(this.viewOptions, this.options);
        if (this.viewOptions.precisionLimit) {
            this.precisionLimit = this.viewOptions.precisionLimit;
        }
        if (this.viewOptions.step <= 0) {
            this.viewOptions.step = 1;
        }
        this.viewOptions.draggableRange = this.range && this.viewOptions.draggableRange;
        this.viewOptions.draggableRangeOnly = this.range && this.viewOptions.draggableRangeOnly;
        if (this.viewOptions.draggableRangeOnly) {
            this.viewOptions.draggableRange = true;
        }
        this.viewOptions.showTicks = this.viewOptions.showTicks ||
            this.viewOptions.showTicksValues ||
            !!this.viewOptions.ticksArray;
        if (this.viewOptions.showTicks && (this.viewOptions.tickStep !== null || this.viewOptions.ticksArray)) {
            this.intermediateTicks = true;
        }
        this.showTicks = this.viewOptions.showTicks;
        this.viewOptions.showSelectionBar = this.viewOptions.showSelectionBar ||
            this.viewOptions.showSelectionBarEnd ||
            this.viewOptions.showSelectionBarFromValue !== null;
        if (this.viewOptions.stepsArray) {
            this.parseStepsArray();
        }
        else {
            if (this.viewOptions.translate) {
                this.translate = this.viewOptions.translate;
            }
            else {
                this.translate = function (value) { return String(value); };
            }
            this.getLegend = this.viewOptions.getLegend;
        }
        if (this.viewOptions.combineLabels) {
            this.combineLabels = this.viewOptions.combineLabels;
        }
        else {
            this.combineLabels = function (minValue, maxValue) {
                return minValue + ' - ' + maxValue;
            };
        }
    };
    SliderComponent.prototype.parseStepsArray = function () {
        var _this = this;
        this.viewOptions.floor = 0;
        this.viewOptions.ceil = this.viewOptions.stepsArray.length - 1;
        this.viewOptions.step = 1;
        if (this.viewOptions.translate) {
            this.translate = this.viewOptions.translate;
        }
        else {
            this.translate = function (modelValue) {
                if (_this.viewOptions.bindIndexForStepsArray) {
                    return String(_this.getStepValue(modelValue));
                }
                return String(modelValue);
            };
        }
        this.getLegend = function (index) {
            var step = _this.viewOptions.stepsArray[index];
            return step.legend;
        };
    };
    SliderComponent.prototype.resetSlider = function () {
        this.manageElementsStyle();
        this.addAccessibility();
        this.setMinAndMax();
        this.updateCeilLab();
        this.updateFloorLab();
        this.unbindEvents();
        this.manageEventsBindings();
        this.setDisabledStateAttr();
        this.calcViewDimensions();
        this.refocusPointerIfNeeded();
    };
    SliderComponent.prototype.refocusPointerIfNeeded = function () {
        if (this.currentFocusElement) {
            this.onPointerFocus(this.currentFocusElement.pointer, this.currentFocusElement.ref);
            this.focusElement(this.currentFocusElement.pointer);
        }
    };
    SliderComponent.prototype.manageElementsStyle = function () {
        var _this = this;
        if (!this.range) {
            this.maxHElem.css('display', 'none');
        }
        else {
            this.maxHElem.css('display', '');
        }
        this.alwaysHide(this.flrLabElem, this.viewOptions.showTicksValues || this.viewOptions.hideLimitLabels);
        this.alwaysHide(this.ceilLabElem, this.viewOptions.showTicksValues || this.viewOptions.hideLimitLabels);
        var hideLabelsForTicks = this.viewOptions.showTicksValues && !this.intermediateTicks;
        this.alwaysHide(this.minLabElem, hideLabelsForTicks || this.viewOptions.hidePointerLabels);
        this.alwaysHide(this.maxLabElem, hideLabelsForTicks || !this.range || this.viewOptions.hidePointerLabels);
        this.alwaysHide(this.cmbLabElem, hideLabelsForTicks || !this.range || this.viewOptions.hidePointerLabels);
        this.alwaysHide(this.selBarElem, !this.range && !this.viewOptions.showSelectionBar);
        this.alwaysHide(this.leftOutSelBar, !this.range || !this.viewOptions.showOuterSelectionBars);
        this.alwaysHide(this.rightOutSelBar, !this.range || !this.viewOptions.showOuterSelectionBars);
        if (this.range && this.viewOptions.showOuterSelectionBars) {
            this.fullBarElem.addClass('ng5-slider-transparent');
        }
        if (this.sliderElementVerticalClass !== this.viewOptions.vertical) {
            this.setVerticalClass();
            setTimeout(function () { _this.resetSlider(); });
        }
        if (this.viewOptions.draggableRange) {
            this.selBarElem.addClass('ng5-slider-draggable');
        }
        else {
            this.selBarElem.removeClass('ng5-slider-draggable');
        }
        if (this.intermediateTicks && this.options.showTicksValues) {
            this.ticksElem.addClass('ng5-slider-ticks-values-under');
        }
    };
    SliderComponent.prototype.alwaysHide = function (el, hide) {
        el.alwaysHide = hide;
        if (hide) {
            this.hideEl(el);
        }
        else {
            this.showEl(el);
        }
    };
    SliderComponent.prototype.manageEventsBindings = function () {
        if (this.viewOptions.disabled || this.viewOptions.readOnly) {
            this.unbindEvents();
        }
        else {
            this.bindEvents();
        }
    };
    SliderComponent.prototype.setDisabledStateAttr = function () {
        this.sliderElementDisabledAttr = this.viewOptions.disabled ? 'disabled' : null;
    };
    SliderComponent.prototype.setVerticalClass = function () {
        this.sliderElementVerticalClass = this.viewOptions.vertical;
    };
    SliderComponent.prototype.resetLabelsValue = function () {
        this.minLabElem.value = undefined;
        this.maxLabElem.value = undefined;
    };
    SliderComponent.prototype.initHandles = function () {
        this.updateLowHandle(this.valueToPosition(this.viewLowValue));
        if (this.range) {
            this.updateHighHandle(this.valueToPosition(this.viewHighValue));
        }
        this.updateSelectionBar();
        if (this.range) {
            this.updateCmbLabel();
        }
        this.updateTicksScale();
    };
    SliderComponent.prototype.setLabelValue = function (value, label) {
        var recalculateDimension = false;
        var noLabelInjection = label.hasClass('no-label-injection');
        if (label.value === undefined ||
            label.value.length !== value.length ||
            (label.value.length > 0 && label.dimension === 0)) {
            recalculateDimension = true;
            label.value = value;
        }
        if (!noLabelInjection) {
            label.html(value);
        }
        if (recalculateDimension) {
            this.calculateElementDimension(label);
        }
    };
    SliderComponent.prototype.setMinAndMax = function () {
        this.step = +this.viewOptions.step;
        this.minValue = this.viewOptions.floor;
        if (this.viewOptions.logScale && this.minValue === 0) {
            throw Error('Can\'t use floor=0 with logarithmic scale');
        }
        if (this.viewOptions.enforceStep) {
            this.viewLowValue = this.roundStep(this.viewLowValue);
            if (this.range) {
                this.viewHighValue = this.roundStep(this.viewHighValue);
            }
        }
        if (this.viewOptions.ceil != null) {
            this.maxValue = this.viewOptions.ceil;
        }
        else {
            this.maxValue = this.viewOptions.ceil = this.range ? this.viewHighValue : this.viewLowValue;
        }
        if (this.viewOptions.enforceRange) {
            this.viewLowValue = this.sanitizeValue(this.viewLowValue);
            if (this.range) {
                this.viewHighValue = this.sanitizeValue(this.viewHighValue);
            }
        }
        this.applyLowValue();
        if (this.range) {
            this.applyHighValue();
        }
        this.valueRange = this.maxValue - this.minValue;
    };
    SliderComponent.prototype.addAccessibility = function () {
        this.updateAriaAttributes();
        this.minHElem.attr('role', 'slider');
        if (this.viewOptions.keyboardSupport &&
            !(this.viewOptions.readOnly || this.viewOptions.disabled)) {
            this.minHElem.attr('tabindex', '0');
        }
        else {
            this.minHElem.attr('tabindex', '');
        }
        if (this.viewOptions.vertical) {
            this.minHElem.attr('aria-orientation', 'vertical');
        }
        if (this.viewOptions.ariaLabel) {
            this.minHElem.attr('aria-label', this.viewOptions.ariaLabel);
        }
        else if (this.viewOptions.ariaLabelledBy) {
            this.minHElem.attr('aria-labelledby', this.viewOptions.ariaLabelledBy);
        }
        if (this.range) {
            this.maxHElem.attr('role', 'slider');
            if (this.viewOptions.keyboardSupport &&
                !(this.viewOptions.readOnly || this.viewOptions.disabled)) {
                this.maxHElem.attr('tabindex', '0');
            }
            else {
                this.maxHElem.attr('tabindex', '');
            }
            if (this.viewOptions.vertical) {
                this.maxHElem.attr('aria-orientation', 'vertical');
            }
            if (this.viewOptions.ariaLabelHigh) {
                this.maxHElem.attr('aria-label', this.viewOptions.ariaLabelHigh);
            }
            else if (this.viewOptions.ariaLabelledByHigh) {
                this.maxHElem.attr('aria-labelledby', this.viewOptions.ariaLabelledByHigh);
            }
        }
    };
    SliderComponent.prototype.updateAriaAttributes = function () {
        this.minHElem.attr('aria-valuenow', this.value.toString());
        this.minHElem.attr('aria-valuetext', this.translate(this.value, LabelType.Low));
        this.minHElem.attr('aria-valuemin', this.minValue.toString());
        this.minHElem.attr('aria-valuemax', this.maxValue.toString());
        if (this.range) {
            this.maxHElem.attr('aria-valuenow', this.highValue.toString());
            this.maxHElem.attr('aria-valuetext', this.translate(this.highValue, LabelType.High));
            this.maxHElem.attr('aria-valuemin', this.minValue.toString());
            this.maxHElem.attr('aria-valuemax', this.maxValue.toString());
        }
    };
    SliderComponent.prototype.calcViewDimensions = function () {
        this.calculateElementDimension(this.minHElem);
        var handleWidth = this.minHElem.dimension;
        this.handleHalfDim = handleWidth / 2;
        this.calculateElementDimension(this.fullBarElem);
        this.barDimension = this.fullBarElem.dimension;
        this.maxPos = this.barDimension - handleWidth;
        var sliderElementBoundingRect = this.elementRef.nativeElement.getBoundingClientRect();
        this.sliderElementPosition = this.viewOptions.vertical ?
            sliderElementBoundingRect.bottom : sliderElementBoundingRect.left;
        if (this.initHasRun) {
            this.updateFloorLab();
            this.updateCeilLab();
            this.initHandles();
        }
    };
    SliderComponent.prototype.updateTicksScale = function () {
        var _this = this;
        if (!this.viewOptions.showTicks) {
            return;
        }
        var ticksArray = this.viewOptions.ticksArray || this.getTicksArray();
        var translate = this.viewOptions.vertical ? 'translateY' : 'translateX';
        if (this.viewOptions.rightToLeft) {
            ticksArray.reverse();
        }
        this.ticks = ticksArray.map(function (value) {
            var position = _this.valueToPosition(value);
            if (_this.viewOptions.vertical) {
                position = _this.maxPos - position;
            }
            var translation = translate + '(' + Math.round(position) + 'px)';
            var tick = new Tick();
            tick.selected = _this.isTickSelected(value);
            tick.style = {
                '-webkit-transform': translation,
                '-moz-transform': translation,
                '-o-transform': translation,
                '-ms-transform': translation,
                transform: translation,
            };
            if (tick.selected && _this.viewOptions.getSelectionBarColor) {
                tick.style['background-color'] = _this.getSelectionBarColor();
            }
            if (!tick.selected && _this.viewOptions.getTickColor) {
                tick.style['background-color'] = _this.getTickColor(value);
            }
            if (_this.viewOptions.ticksTooltip) {
                tick.tooltip = _this.viewOptions.ticksTooltip(value);
                tick.tooltipPlacement = _this.viewOptions.vertical ? 'right' : 'top';
            }
            if (_this.viewOptions.showTicksValues && (value % _this.viewOptions.tickValueStep === 0)) {
                tick.value = _this.getDisplayValue(value, LabelType.TickValue);
                if (_this.viewOptions.ticksValuesTooltip) {
                    tick.valueTooltip = _this.viewOptions.ticksValuesTooltip(value);
                    tick.valueTooltipPlacement = _this.viewOptions.vertical
                        ? 'right'
                        : 'top';
                }
            }
            if (_this.getLegend) {
                var legend = _this.getLegend(value);
                if (legend) {
                    tick.legend = legend;
                }
            }
            return tick;
        });
    };
    SliderComponent.prototype.getTicksArray = function () {
        var step = (this.viewOptions.tickStep !== null) ? this.viewOptions.tickStep : this.step;
        var ticksArray = [];
        for (var value = this.minValue; value <= this.maxValue; value += step) {
            ticksArray.push(value);
        }
        return ticksArray;
    };
    SliderComponent.prototype.isTickSelected = function (value) {
        if (!this.range) {
            if (this.viewOptions.showSelectionBarFromValue !== null) {
                var center = this.viewOptions.showSelectionBarFromValue;
                if (this.viewLowValue > center &&
                    value >= center &&
                    value <= this.viewLowValue) {
                    return true;
                }
                else if (this.viewLowValue < center &&
                    value <= center &&
                    value >= this.viewLowValue) {
                    return true;
                }
            }
            else if (this.viewOptions.showSelectionBarEnd) {
                if (value >= this.viewLowValue) {
                    return true;
                }
            }
            else if (this.viewOptions.showSelectionBar && value <= this.viewLowValue) {
                return true;
            }
        }
        if (this.range && value >= this.viewLowValue && value <= this.viewHighValue) {
            return true;
        }
        return false;
    };
    SliderComponent.prototype.updateFloorLab = function () {
        this.setLabelValue(this.getDisplayValue(this.minValue, LabelType.Floor), this.flrLabElem);
        this.calculateElementDimension(this.flrLabElem);
        var position = this.viewOptions.rightToLeft
            ? this.barDimension - this.flrLabElem.dimension
            : 0;
        this.setPosition(this.flrLabElem, position);
    };
    SliderComponent.prototype.updateCeilLab = function () {
        this.setLabelValue(this.getDisplayValue(this.maxValue, LabelType.Ceil), this.ceilLabElem);
        this.calculateElementDimension(this.ceilLabElem);
        var position = this.viewOptions.rightToLeft
            ? 0
            : this.barDimension - this.ceilLabElem.dimension;
        this.setPosition(this.ceilLabElem, position);
    };
    SliderComponent.prototype.updateHandles = function (which, newPos) {
        if (which === HandleType.Low) {
            this.updateLowHandle(newPos);
        }
        else {
            this.updateHighHandle(newPos);
        }
        this.updateSelectionBar();
        this.updateTicksScale();
        if (this.range) {
            this.updateCmbLabel();
        }
    };
    SliderComponent.prototype.getHandleLabelPos = function (labelType, newPos) {
        var labelDimension = labelType === HandleLabelType.Min ? this.minLabElem.dimension : this.maxLabElem.dimension;
        var nearHandlePos = newPos - labelDimension / 2 + this.handleHalfDim;
        var endOfBarPos = this.barDimension - labelDimension;
        if (!this.viewOptions.boundPointerLabels) {
            return nearHandlePos;
        }
        if ((this.viewOptions.rightToLeft && labelType === HandleLabelType.Min) ||
            (!this.viewOptions.rightToLeft && labelType === HandleLabelType.Max)) {
            return Math.min(nearHandlePos, endOfBarPos);
        }
        else {
            return Math.min(Math.max(nearHandlePos, 0), endOfBarPos);
        }
    };
    SliderComponent.prototype.updateLowHandle = function (newPos) {
        this.setPosition(this.minHElem, newPos);
        this.setLabelValue(this.getDisplayValue(this.viewLowValue, LabelType.Low), this.minLabElem);
        this.setPosition(this.minLabElem, this.getHandleLabelPos(HandleLabelType.Min, newPos));
        if (this.viewOptions.getPointerColor) {
            var pointercolor = this.getPointerColor(PointerType.Min);
            this.minPointerStyle = {
                backgroundColor: pointercolor,
            };
        }
        if (this.viewOptions.autoHideLimitLabels) {
            this.shFloorCeil();
        }
    };
    SliderComponent.prototype.updateHighHandle = function (newPos) {
        this.setPosition(this.maxHElem, newPos);
        this.setLabelValue(this.getDisplayValue(this.viewHighValue, LabelType.High), this.maxLabElem);
        this.setPosition(this.maxLabElem, this.getHandleLabelPos(HandleLabelType.Max, newPos));
        if (this.viewOptions.getPointerColor) {
            var pointercolor = this.getPointerColor(PointerType.Max);
            this.maxPointerStyle = {
                backgroundColor: pointercolor,
            };
        }
        if (this.viewOptions.autoHideLimitLabels) {
            this.shFloorCeil();
        }
    };
    SliderComponent.prototype.shFloorCeil = function () {
        if (this.viewOptions.hidePointerLabels) {
            return;
        }
        var flHidden = false;
        var clHidden = false;
        var isMinLabAtFloor = this.isLabelBelowFloorLab(this.minLabElem);
        var isMinLabAtCeil = this.isLabelAboveCeilLab(this.minLabElem);
        var isMaxLabAtCeil = this.isLabelAboveCeilLab(this.maxLabElem);
        var isCmbLabAtFloor = this.isLabelBelowFloorLab(this.cmbLabElem);
        var isCmbLabAtCeil = this.isLabelAboveCeilLab(this.cmbLabElem);
        if (isMinLabAtFloor) {
            flHidden = true;
            this.hideEl(this.flrLabElem);
        }
        else {
            flHidden = false;
            this.showEl(this.flrLabElem);
        }
        if (isMinLabAtCeil) {
            clHidden = true;
            this.hideEl(this.ceilLabElem);
        }
        else {
            clHidden = false;
            this.showEl(this.ceilLabElem);
        }
        if (this.range) {
            var hideCeil = this.cmbLabelShown ? isCmbLabAtCeil : isMaxLabAtCeil;
            var hideFloor = this.cmbLabelShown
                ? isCmbLabAtFloor
                : isMinLabAtFloor;
            if (hideCeil) {
                this.hideEl(this.ceilLabElem);
            }
            else if (!clHidden) {
                this.showEl(this.ceilLabElem);
            }
            if (hideFloor) {
                this.hideEl(this.flrLabElem);
            }
            else if (!flHidden) {
                this.showEl(this.flrLabElem);
            }
        }
    };
    SliderComponent.prototype.isLabelBelowFloorLab = function (label) {
        var isRTL = this.viewOptions.rightToLeft;
        var pos = label.position;
        var dim = label.dimension;
        var floorPos = this.flrLabElem.position;
        var floorDim = this.flrLabElem.dimension;
        return isRTL
            ? pos + dim >= floorPos - 2
            : pos <= floorPos + floorDim + 2;
    };
    SliderComponent.prototype.isLabelAboveCeilLab = function (label) {
        var isRTL = this.viewOptions.rightToLeft;
        var pos = label.position;
        var dim = label.dimension;
        var ceilPos = this.ceilLabElem.position;
        var ceilDim = this.ceilLabElem.dimension;
        return isRTL ? pos <= ceilPos + ceilDim + 2 : pos + dim >= ceilPos - 2;
    };
    SliderComponent.prototype.updateSelectionBar = function () {
        var position = 0;
        var dimension = 0;
        var isSelectionBarFromRight = this.viewOptions.rightToLeft
            ? !this.viewOptions.showSelectionBarEnd
            : this.viewOptions.showSelectionBarEnd;
        var positionForRange = this.viewOptions.rightToLeft
            ? this.maxHElem.position + this.handleHalfDim
            : this.minHElem.position + this.handleHalfDim;
        if (this.range) {
            dimension = Math.abs(this.maxHElem.position - this.minHElem.position);
            position = positionForRange;
        }
        else {
            if (this.viewOptions.showSelectionBarFromValue !== null) {
                var center = this.viewOptions.showSelectionBarFromValue;
                var centerPosition = this.valueToPosition(center);
                var isModelGreaterThanCenter = this.viewOptions.rightToLeft
                    ? this.viewLowValue <= center
                    : this.viewLowValue > center;
                if (isModelGreaterThanCenter) {
                    dimension = this.minHElem.position - centerPosition;
                    position = centerPosition + this.handleHalfDim;
                }
                else {
                    dimension = centerPosition - this.minHElem.position;
                    position = this.minHElem.position + this.handleHalfDim;
                }
            }
            else if (isSelectionBarFromRight) {
                dimension = Math.ceil(Math.abs(this.maxPos - this.minHElem.position) + this.handleHalfDim);
                position = Math.floor(this.minHElem.position + this.handleHalfDim);
            }
            else {
                dimension = this.minHElem.position + this.handleHalfDim;
                position = 0;
            }
        }
        this.setDimension(this.selBarElem, dimension);
        this.setPosition(this.selBarElem, position);
        if (this.range && this.viewOptions.showOuterSelectionBars) {
            if (this.viewOptions.rightToLeft) {
                this.setDimension(this.rightOutSelBar, position);
                this.setPosition(this.rightOutSelBar, 0);
                this.calculateElementDimension(this.fullBarElem);
                this.setDimension(this.leftOutSelBar, this.fullBarElem.dimension - (position + dimension));
                this.setPosition(this.leftOutSelBar, position + dimension);
            }
            else {
                this.setDimension(this.leftOutSelBar, position);
                this.setPosition(this.leftOutSelBar, 0);
                this.calculateElementDimension(this.fullBarElem);
                this.setDimension(this.rightOutSelBar, this.fullBarElem.dimension - (position + dimension));
                this.setPosition(this.rightOutSelBar, position + dimension);
            }
        }
        if (this.viewOptions.getSelectionBarColor) {
            var color = this.getSelectionBarColor();
            this.barStyle = {
                backgroundColor: color,
            };
        }
        else if (this.viewOptions.selectionBarGradient) {
            var offset = this.viewOptions.showSelectionBarFromValue !== null
                ? this.valueToPosition(this.viewOptions.showSelectionBarFromValue)
                : 0;
            var reversed = (offset - position > 0 && !isSelectionBarFromRight) || (offset - position <= 0 && isSelectionBarFromRight);
            var direction = this.viewOptions.vertical
                ? reversed ? 'bottom' : 'top'
                : reversed ? 'left' : 'right';
            this.barStyle = {
                backgroundImage: 'linear-gradient(to ' +
                    direction +
                    ', ' +
                    this.viewOptions.selectionBarGradient.from +
                    ' 0%,' +
                    this.viewOptions.selectionBarGradient.to +
                    ' 100%)',
            };
            if (this.viewOptions.vertical) {
                this.barStyle.backgroundPosition =
                    'center ' +
                        (offset +
                            dimension +
                            position +
                            (reversed ? -this.handleHalfDim : 0)) +
                        'px';
                this.barStyle.backgroundSize =
                    '100% ' + (this.barDimension - this.handleHalfDim) + 'px';
            }
            else {
                this.barStyle.backgroundPosition =
                    offset -
                        position +
                        (reversed ? this.handleHalfDim : 0) +
                        'px center';
                this.barStyle.backgroundSize =
                    this.barDimension - this.handleHalfDim + 'px 100%';
            }
        }
    };
    SliderComponent.prototype.getSelectionBarColor = function () {
        if (this.range) {
            return this.viewOptions.getSelectionBarColor(this.value, this.highValue);
        }
        return this.viewOptions.getSelectionBarColor(this.value);
    };
    SliderComponent.prototype.getPointerColor = function (pointerType) {
        if (pointerType === PointerType.Max) {
            return this.viewOptions.getPointerColor(this.highValue, pointerType);
        }
        return this.viewOptions.getPointerColor(this.value, pointerType);
    };
    SliderComponent.prototype.getTickColor = function (value) {
        return this.viewOptions.getTickColor(value);
    };
    SliderComponent.prototype.updateCmbLabel = function () {
        var isLabelOverlap = null;
        if (this.viewOptions.rightToLeft) {
            isLabelOverlap =
                this.minLabElem.position - this.minLabElem.dimension - 10 <= this.maxLabElem.position;
        }
        else {
            isLabelOverlap =
                this.minLabElem.position + this.minLabElem.dimension + 10 >= this.maxLabElem.position;
        }
        if (isLabelOverlap) {
            var lowTr = this.getDisplayValue(this.viewLowValue, LabelType.Low);
            var highTr = this.getDisplayValue(this.viewHighValue, LabelType.High);
            var labelVal = this.viewOptions.rightToLeft
                ? this.combineLabels(highTr, lowTr)
                : this.combineLabels(lowTr, highTr);
            this.setLabelValue(labelVal, this.cmbLabElem);
            var pos = this.viewOptions.boundPointerLabels
                ? Math.min(Math.max(this.selBarElem.position +
                    this.selBarElem.dimension / 2 -
                    this.cmbLabElem.dimension / 2, 0), this.barDimension - this.cmbLabElem.dimension)
                : this.selBarElem.position + this.selBarElem.dimension / 2 - this.cmbLabElem.dimension / 2;
            this.setPosition(this.cmbLabElem, pos);
            this.cmbLabelShown = true;
            this.hideEl(this.minLabElem);
            this.hideEl(this.maxLabElem);
            this.showEl(this.cmbLabElem);
        }
        else {
            this.cmbLabelShown = false;
            this.updateHighHandle(this.valueToPosition(this.viewHighValue));
            this.updateLowHandle(this.valueToPosition(this.viewLowValue));
            this.showEl(this.maxLabElem);
            this.showEl(this.minLabElem);
            this.hideEl(this.cmbLabElem);
        }
        if (this.viewOptions.autoHideLimitLabels) {
            this.shFloorCeil();
        }
    };
    SliderComponent.prototype.getDisplayValue = function (value, which) {
        if (this.viewOptions.stepsArray && !this.viewOptions.bindIndexForStepsArray) {
            value = this.getStepValue(value);
        }
        return this.translate(value, which);
    };
    SliderComponent.prototype.roundStep = function (value, customStep) {
        var step = customStep ? customStep : this.step;
        var steppedDifference = MathHelper.roundToPrecisionLimit((value - this.minValue) / step, this.precisionLimit);
        steppedDifference = Math.round(steppedDifference) * step;
        return MathHelper.roundToPrecisionLimit(this.minValue + steppedDifference, this.precisionLimit);
    };
    SliderComponent.prototype.hideEl = function (element) {
        element.css('visibility', 'hidden');
    };
    SliderComponent.prototype.showEl = function (element) {
        if (!!element.alwaysHide) {
            return;
        }
        element.css('visibility', 'visible');
    };
    SliderComponent.prototype.setPosition = function (elem, pos) {
        elem.position = pos;
        if (this.viewOptions.vertical) {
            elem.css('bottom', Math.round(pos) + 'px');
        }
        else {
            elem.css('left', Math.round(pos) + 'px');
        }
    };
    SliderComponent.prototype.calculateElementDimension = function (elem) {
        var val = elem.getBoundingClientRect();
        if (this.viewOptions.vertical) {
            elem.dimension = (val.bottom - val.top) * this.viewOptions.scale;
        }
        else {
            elem.dimension = (val.right - val.left) * this.viewOptions.scale;
        }
    };
    SliderComponent.prototype.setDimension = function (elem, dim) {
        elem.dimension = dim;
        if (this.viewOptions.vertical) {
            elem.css('height', Math.round(dim) + 'px');
        }
        else {
            elem.css('width', Math.round(dim) + 'px');
        }
        return dim;
    };
    SliderComponent.prototype.sanitizeValue = function (val) {
        return Math.min(Math.max(val, this.minValue), this.maxValue);
    };
    SliderComponent.prototype.valueToPosition = function (val) {
        var fn = ValueHelper.linearValueToPosition;
        if (this.viewOptions.customValueToPosition) {
            fn = this.viewOptions.customValueToPosition;
        }
        else if (this.viewOptions.logScale) {
            fn = ValueHelper.logValueToPosition;
        }
        val = this.sanitizeValue(val);
        var percent = fn(val, this.minValue, this.maxValue) || 0;
        if (this.viewOptions.rightToLeft) {
            percent = 1 - percent;
        }
        return percent * this.maxPos;
    };
    SliderComponent.prototype.positionToValue = function (position) {
        var percent = position / this.maxPos;
        if (this.viewOptions.rightToLeft) {
            percent = 1 - percent;
        }
        var fn = ValueHelper.linearPositionToValue;
        if (this.viewOptions.customPositionToValue) {
            fn = this.viewOptions.customPositionToValue;
        }
        else if (this.viewOptions.logScale) {
            fn = ValueHelper.logPositionToValue;
        }
        return fn(percent, this.minValue, this.maxValue) || 0;
    };
    SliderComponent.prototype.getEventXY = function (event, targetTouchId) {
        if (event instanceof MouseEvent) {
            return this.viewOptions.vertical ? event.clientY : event.clientX;
        }
        var touchIndex = 0;
        var touches = event.touches;
        if (targetTouchId !== undefined) {
            for (var i = 0; i < touches.length; i++) {
                if (touches[i].identifier === targetTouchId) {
                    touchIndex = i;
                    break;
                }
            }
        }
        return this.viewOptions.vertical ? touches[touchIndex].clientY : touches[touchIndex].clientX;
    };
    SliderComponent.prototype.getEventPosition = function (event, targetTouchId) {
        var sliderPos = this.sliderElementPosition;
        var eventPos = 0;
        if (this.viewOptions.vertical) {
            eventPos = -this.getEventXY(event, targetTouchId) + sliderPos;
        }
        else {
            eventPos = this.getEventXY(event, targetTouchId) - sliderPos;
        }
        return eventPos * this.viewOptions.scale - this.handleHalfDim;
    };
    SliderComponent.prototype.getNearestHandle = function (event) {
        if (!this.range) {
            return this.minHElem;
        }
        var position = this.getEventPosition(event);
        var distanceMin = Math.abs(position - this.minHElem.position);
        var distanceMax = Math.abs(position - this.maxHElem.position);
        if (distanceMin < distanceMax) {
            return this.minHElem;
        }
        else if (distanceMin > distanceMax) {
            return this.maxHElem;
        }
        else if (!this.viewOptions.rightToLeft) {
            return position < this.minHElem.position ? this.minHElem : this.maxHElem;
        }
        else {
            return position > this.minHElem.position ? this.minHElem : this.maxHElem;
        }
    };
    SliderComponent.prototype.focusElement = function (el) {
        el.focus();
    };
    SliderComponent.prototype.bindEvents = function () {
        var _this = this;
        var draggableRange = this.viewOptions.draggableRange;
        if (!this.viewOptions.onlyBindHandles) {
            this.selBarElem.on('mousedown', function (event) { return _this.onBarStart(draggableRange, null, event, true, true, true); });
        }
        if (this.viewOptions.draggableRangeOnly) {
            this.minHElem.on('mousedown', function (event) { return _this.onBarStart(draggableRange, null, event, true, true); });
            this.maxHElem.on('mousedown', function (event) { return _this.onBarStart(draggableRange, null, event, true, true); });
        }
        else {
            this.minHElem.on('mousedown', function (event) { return _this.onStart(_this.minHElem, HandleType.Low, event, true, true); });
            if (this.range) {
                this.maxHElem.on('mousedown', function (event) { return _this.onStart(_this.maxHElem, HandleType.High, event, true, true); });
            }
            if (!this.viewOptions.onlyBindHandles) {
                this.fullBarElem.on('mousedown', function (event) { _this.onStart(null, null, event, true, true, true); });
                this.ticksElem.on('mousedown', function (event) { _this.onStart(null, null, event, true, true, true, true); });
            }
        }
        if (!this.viewOptions.onlyBindHandles) {
            this.selBarElem.onPassive('touchstart', function (event) { return _this.onBarStart(draggableRange, null, event, true, true); });
        }
        if (this.viewOptions.draggableRangeOnly) {
            this.minHElem.onPassive('touchstart', function (event) { return _this.onBarStart(draggableRange, null, event, true, true); });
            this.maxHElem.onPassive('touchstart', function (event) { return _this.onBarStart(draggableRange, null, event, true, true); });
        }
        else {
            this.minHElem.onPassive('touchstart', function (event) { return _this.onStart(_this.minHElem, HandleType.Low, event, true, true); });
            if (this.range) {
                this.maxHElem.onPassive('touchstart', function (event) { return _this.onStart(_this.maxHElem, HandleType.High, event, true, true); });
            }
            if (!this.viewOptions.onlyBindHandles) {
                this.fullBarElem.onPassive('touchstart', function (event) { return _this.onStart(null, null, event, true, true, true); });
                this.ticksElem.onPassive('touchstart', function (event) { return _this.onStart(null, null, event, false, false, true, true); });
            }
        }
        if (this.viewOptions.keyboardSupport) {
            this.minHElem.on('focus', function () { return _this.onPointerFocus(_this.minHElem, HandleType.Low); });
            if (this.range) {
                this.maxHElem.on('focus', function () { return _this.onPointerFocus(_this.maxHElem, HandleType.High); });
            }
        }
    };
    SliderComponent.prototype.unbindEvents = function () {
        this.minHElem.off();
        this.maxHElem.off();
        this.fullBarElem.off();
        this.selBarElem.off();
        this.ticksElem.off();
    };
    SliderComponent.prototype.onBarStart = function (draggableRange, pointer, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd) {
        if (draggableRange) {
            this.onDragStart(pointer, HandleType.High, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd);
        }
        else {
            this.onStart(pointer, HandleType.Low, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd);
        }
    };
    SliderComponent.prototype.onStart = function (pointer, ref, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd) {
        var _this = this;
        var moveEvent = '';
        var endEvent = '';
        if (CompatibilityHelper.isTouchEvent(event)) {
            moveEvent = 'touchmove';
            endEvent = 'touchend';
        }
        else {
            moveEvent = 'mousemove';
            endEvent = 'mouseup';
        }
        event.stopPropagation();
        if (!CompatibilityHelper.isTouchEvent(event) || !detectPassiveEvents.hasSupport) {
            event.preventDefault();
        }
        this.calcViewDimensions();
        if (pointer) {
            this.tracking = ref;
        }
        else {
            pointer = this.getNearestHandle(event);
            this.tracking = pointer === this.minHElem ? HandleType.Low : HandleType.High;
        }
        pointer.addClass('ng5-slider-active');
        if (this.viewOptions.keyboardSupport) {
            this.focusElement(pointer);
        }
        if (bindMove) {
            var ehMove = function (e) { return _this.dragging.active ? _this.onDragMove(pointer, e) : _this.onMove(pointer, e); };
            if (this.onMoveUnsubscribe !== null) {
                this.onMoveUnsubscribe();
            }
            this.onMoveUnsubscribe = this.renderer.listen('document', moveEvent, ehMove);
        }
        if (bindEnd) {
            var ehEnd = function (e) { return _this.onEnd(e); };
            if (this.onEndUnsubscribe !== null) {
                this.onEndUnsubscribe();
            }
            this.onEndUnsubscribe = this.renderer.listen('document', endEvent, ehEnd);
        }
        this.userChangeStart.emit(this.getChangeContext());
        if (CompatibilityHelper.isTouchEvent(event) && ((event)).changedTouches) {
            if (!this.touchId) {
                this.isDragging = true;
                this.touchId = ((event)).changedTouches[0].identifier;
            }
        }
        if (simulateImmediateMove) {
            this.onMove(pointer, event, true);
        }
        if (simulateImmediateEnd) {
            this.onEnd(event);
        }
    };
    SliderComponent.prototype.onMove = function (pointer, event, fromTick) {
        var touchForThisSlider;
        if (CompatibilityHelper.isTouchEvent(event)) {
            var changedTouches = ((event)).changedTouches;
            for (var i = 0; i < changedTouches.length; i++) {
                if (changedTouches[i].identifier === this.touchId) {
                    touchForThisSlider = changedTouches[i];
                    break;
                }
            }
            if (!touchForThisSlider) {
                return;
            }
        }
        var newPos = this.getEventPosition(event, touchForThisSlider ? touchForThisSlider.identifier : undefined);
        var newValue;
        var ceilValue = this.viewOptions.rightToLeft
            ? this.minValue
            : this.maxValue;
        var flrValue = this.viewOptions.rightToLeft ? this.maxValue : this.minValue;
        if (newPos <= 0) {
            newValue = flrValue;
        }
        else if (newPos >= this.maxPos) {
            newValue = ceilValue;
        }
        else {
            newValue = this.positionToValue(newPos);
            if (fromTick && this.viewOptions.tickStep !== null) {
                newValue = this.roundStep(newValue, this.viewOptions.tickStep);
            }
            else {
                newValue = this.roundStep(newValue);
            }
        }
        this.positionTrackingHandle(newValue);
    };
    SliderComponent.prototype.onEnd = function (event) {
        if (CompatibilityHelper.isTouchEvent(event)) {
            var changedTouches = ((event)).changedTouches;
            if (changedTouches[0].identifier !== this.touchId) {
                return;
            }
        }
        this.isDragging = false;
        this.touchId = null;
        if (!this.viewOptions.keyboardSupport) {
            this.minHElem.removeClass('ng5-slider-active');
            this.maxHElem.removeClass('ng5-slider-active');
            this.tracking = null;
        }
        this.dragging.active = false;
        if (this.onMoveUnsubscribe !== null) {
            this.onMoveUnsubscribe();
        }
        if (this.onEndUnsubscribe !== null) {
            this.onEndUnsubscribe();
        }
        this.userChangeEnd.emit(this.getChangeContext());
    };
    SliderComponent.prototype.onPointerFocus = function (pointer, ref) {
        var _this = this;
        this.tracking = ref;
        pointer.on('blur', function () { return _this.onPointerBlur(pointer); });
        pointer.on('keydown', function (event) { return _this.onKeyboardEvent(event); });
        pointer.on('keyup', function () { return _this.onKeyUp(); });
        this.firstKeyDown = true;
        pointer.addClass('ng5-slider-active');
        this.currentFocusElement = {
            pointer: pointer,
            ref: ref,
        };
    };
    SliderComponent.prototype.onKeyUp = function () {
        this.firstKeyDown = true;
        this.userChangeEnd.emit(this.getChangeContext());
    };
    SliderComponent.prototype.onPointerBlur = function (pointer) {
        pointer.off('blur');
        pointer.off('keydown');
        pointer.off('keyup');
        pointer.removeClass('ng5-slider-active');
        if (!this.isDragging) {
            this.tracking = null;
            this.currentFocusElement = null;
        }
    };
    SliderComponent.prototype.getKeyActions = function (currentValue) {
        var increaseStep = currentValue + this.step;
        var decreaseStep = currentValue - this.step;
        var increasePage = currentValue + this.valueRange / 10;
        var decreasePage = currentValue - this.valueRange / 10;
        if (this.viewOptions.reversedControls) {
            increaseStep = currentValue - this.step;
            decreaseStep = currentValue + this.step;
            increasePage = currentValue - this.valueRange / 10;
            decreasePage = currentValue + this.valueRange / 10;
        }
        var actions = {
            UP: increaseStep,
            DOWN: decreaseStep,
            LEFT: decreaseStep,
            RIGHT: increaseStep,
            PAGEUP: increasePage,
            PAGEDOWN: decreasePage,
            HOME: this.viewOptions.reversedControls ? this.maxValue : this.minValue,
            END: this.viewOptions.reversedControls ? this.minValue : this.maxValue,
        };
        if (this.viewOptions.rightToLeft) {
            actions["LEFT"] = increaseStep;
            actions["RIGHT"] = decreaseStep;
            if (this.viewOptions.vertical) {
                actions["UP"] = decreaseStep;
                actions["DOWN"] = increaseStep;
            }
        }
        return actions;
    };
    SliderComponent.prototype.onKeyboardEvent = function (event) {
        var currentValue = this.getCurrentTrackingValue();
        var keyCode = event.keyCode || event.which;
        var keys = {
            38: 'UP',
            40: 'DOWN',
            37: 'LEFT',
            39: 'RIGHT',
            33: 'PAGEUP',
            34: 'PAGEDOWN',
            36: 'HOME',
            35: 'END',
        };
        var actions = this.getKeyActions(currentValue);
        var key = keys[keyCode];
        var action = actions[key];
        if (action == null || this.tracking === null) {
            return;
        }
        event.preventDefault();
        if (this.firstKeyDown) {
            this.firstKeyDown = false;
            this.userChangeStart.emit(this.getChangeContext());
        }
        var newValue = this.roundStep(this.sanitizeValue(action));
        if (!this.viewOptions.draggableRangeOnly) {
            this.positionTrackingHandle(newValue);
        }
        else {
            var difference = this.viewHighValue - this.viewLowValue;
            var newMinValue = void 0;
            var newMaxValue = void 0;
            if (this.tracking === HandleType.Low) {
                newMinValue = newValue;
                newMaxValue = newValue + difference;
                if (newMaxValue > this.maxValue) {
                    newMaxValue = this.maxValue;
                    newMinValue = newMaxValue - difference;
                }
            }
            else {
                newMaxValue = newValue;
                newMinValue = newValue - difference;
                if (newMinValue < this.minValue) {
                    newMinValue = this.minValue;
                    newMaxValue = newMinValue + difference;
                }
            }
            this.positionTrackingBar(newMinValue, newMaxValue);
        }
    };
    SliderComponent.prototype.onDragStart = function (pointer, ref, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd) {
        var position = this.getEventPosition(event);
        this.dragging = new Dragging();
        this.dragging.active = true;
        this.dragging.value = this.positionToValue(position);
        this.dragging.difference = this.viewHighValue - this.viewLowValue;
        this.dragging.lowLimit = this.viewOptions.rightToLeft
            ? this.minHElem.position - position
            : position - this.minHElem.position;
        this.dragging.highLimit = this.viewOptions.rightToLeft
            ? position - this.maxHElem.position
            : this.maxHElem.position - position;
        this.onStart(pointer, ref, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd);
    };
    SliderComponent.prototype.getMinValue = function (newPos, outOfBounds, isAbove) {
        var isRTL = this.viewOptions.rightToLeft;
        var value = null;
        if (outOfBounds) {
            if (isAbove) {
                value = isRTL
                    ? this.minValue
                    : this.maxValue - this.dragging.difference;
            }
            else {
                value = isRTL
                    ? this.maxValue - this.dragging.difference
                    : this.minValue;
            }
        }
        else {
            value = isRTL
                ? this.positionToValue(newPos + this.dragging.lowLimit)
                : this.positionToValue(newPos - this.dragging.lowLimit);
        }
        return this.roundStep(value);
    };
    SliderComponent.prototype.getMaxValue = function (newPos, outOfBounds, isAbove) {
        var isRTL = this.viewOptions.rightToLeft;
        var value = null;
        if (outOfBounds) {
            if (isAbove) {
                value = isRTL
                    ? this.minValue + this.dragging.difference
                    : this.maxValue;
            }
            else {
                value = isRTL
                    ? this.maxValue
                    : this.minValue + this.dragging.difference;
            }
        }
        else {
            if (isRTL) {
                value =
                    this.positionToValue(newPos + this.dragging.lowLimit) +
                        this.dragging.difference;
            }
            else {
                value =
                    this.positionToValue(newPos - this.dragging.lowLimit) +
                        this.dragging.difference;
            }
        }
        return this.roundStep(value);
    };
    SliderComponent.prototype.onDragMove = function (pointer, event) {
        var newPos = this.getEventPosition(event);
        var ceilLimit, flrLimit, flrHElem, ceilHElem;
        if (this.viewOptions.rightToLeft) {
            ceilLimit = this.dragging.lowLimit;
            flrLimit = this.dragging.highLimit;
            flrHElem = this.maxHElem;
            ceilHElem = this.minHElem;
        }
        else {
            ceilLimit = this.dragging.highLimit;
            flrLimit = this.dragging.lowLimit;
            flrHElem = this.minHElem;
            ceilHElem = this.maxHElem;
        }
        var isUnderFlrLimit = newPos <= flrLimit;
        var isOverCeilLimit = newPos >= this.maxPos - ceilLimit;
        var newMinValue;
        var newMaxValue;
        if (isUnderFlrLimit) {
            if (flrHElem.position === 0) {
                return;
            }
            newMinValue = this.getMinValue(newPos, true, false);
            newMaxValue = this.getMaxValue(newPos, true, false);
        }
        else if (isOverCeilLimit) {
            if (ceilHElem.position === this.maxPos) {
                return;
            }
            newMaxValue = this.getMaxValue(newPos, true, true);
            newMinValue = this.getMinValue(newPos, true, true);
        }
        else {
            newMinValue = this.getMinValue(newPos, false, false);
            newMaxValue = this.getMaxValue(newPos, false, false);
        }
        this.positionTrackingBar(newMinValue, newMaxValue);
    };
    SliderComponent.prototype.positionTrackingBar = function (newMinValue, newMaxValue) {
        if (this.viewOptions.minLimit != null &&
            newMinValue < this.viewOptions.minLimit) {
            newMinValue = this.viewOptions.minLimit;
            newMaxValue = MathHelper.roundToPrecisionLimit(newMinValue + this.dragging.difference, this.precisionLimit);
        }
        if (this.viewOptions.maxLimit != null &&
            newMaxValue > this.viewOptions.maxLimit) {
            newMaxValue = this.viewOptions.maxLimit;
            newMinValue = MathHelper.roundToPrecisionLimit(newMaxValue - this.dragging.difference, this.precisionLimit);
        }
        this.viewLowValue = newMinValue;
        this.viewHighValue = newMaxValue;
        this.applyLowValue();
        if (this.range) {
            this.applyHighValue();
        }
        this.applyModel(true);
        this.updateHandles(HandleType.Low, this.valueToPosition(newMinValue));
        this.updateHandles(HandleType.High, this.valueToPosition(newMaxValue));
    };
    SliderComponent.prototype.positionTrackingHandle = function (newValue) {
        var valueChanged = false;
        newValue = this.applyMinMaxLimit(newValue);
        if (this.range) {
            if (this.viewOptions.pushRange) {
                newValue = this.applyPushRange(newValue);
                valueChanged = true;
            }
            else {
                if (this.viewOptions.noSwitching) {
                    if (this.tracking === HandleType.Low && newValue > this.viewHighValue) {
                        newValue = this.applyMinMaxRange(this.viewHighValue);
                    }
                    else if (this.tracking === HandleType.High &&
                        newValue < this.viewLowValue) {
                        newValue = this.applyMinMaxRange(this.viewLowValue);
                    }
                }
                newValue = this.applyMinMaxRange(newValue);
                if (this.tracking === HandleType.Low && newValue > this.viewHighValue) {
                    this.viewLowValue = this.viewHighValue;
                    this.applyLowValue();
                    this.applyModel(false);
                    this.updateHandles(HandleType.Low, this.maxHElem.position);
                    this.updateAriaAttributes();
                    this.tracking = HandleType.High;
                    this.minHElem.removeClass('ng5-slider-active');
                    this.maxHElem.addClass('ng5-slider-active');
                    if (this.viewOptions.keyboardSupport) {
                        this.focusElement(this.maxHElem);
                    }
                    valueChanged = true;
                }
                else if (this.tracking === HandleType.High &&
                    newValue < this.viewLowValue) {
                    this.viewHighValue = this.viewLowValue;
                    this.applyHighValue();
                    this.applyModel(false);
                    this.updateHandles(HandleType.High, this.minHElem.position);
                    this.updateAriaAttributes();
                    this.tracking = HandleType.Low;
                    this.maxHElem.removeClass('ng5-slider-active');
                    this.minHElem.addClass('ng5-slider-active');
                    if (this.viewOptions.keyboardSupport) {
                        this.focusElement(this.minHElem);
                    }
                    valueChanged = true;
                }
            }
        }
        if (this.getCurrentTrackingValue() !== newValue) {
            if (this.tracking === HandleType.Low) {
                this.viewLowValue = newValue;
                this.applyLowValue();
            }
            else {
                this.viewHighValue = newValue;
                this.applyHighValue();
            }
            this.applyModel(false);
            this.updateHandles(this.tracking, this.valueToPosition(newValue));
            this.updateAriaAttributes();
            valueChanged = true;
        }
        if (valueChanged) {
            this.applyModel(true);
        }
    };
    SliderComponent.prototype.applyMinMaxLimit = function (newValue) {
        if (this.viewOptions.minLimit != null && newValue < this.viewOptions.minLimit) {
            return this.viewOptions.minLimit;
        }
        if (this.viewOptions.maxLimit != null && newValue > this.viewOptions.maxLimit) {
            return this.viewOptions.maxLimit;
        }
        return newValue;
    };
    SliderComponent.prototype.applyMinMaxRange = function (newValue) {
        var oppositeValue = this.tracking === HandleType.Low ? this.viewHighValue : this.viewLowValue;
        var difference = Math.abs(newValue - oppositeValue);
        if (this.viewOptions.minRange != null) {
            if (difference < this.viewOptions.minRange) {
                if (this.tracking === HandleType.Low) {
                    return MathHelper.roundToPrecisionLimit(this.viewHighValue - this.viewOptions.minRange, this.precisionLimit);
                }
                else {
                    return MathHelper.roundToPrecisionLimit(this.viewLowValue + this.viewOptions.minRange, this.precisionLimit);
                }
            }
        }
        if (this.viewOptions.maxRange != null) {
            if (difference > this.viewOptions.maxRange) {
                if (this.tracking === HandleType.Low) {
                    return MathHelper.roundToPrecisionLimit(this.viewHighValue - this.viewOptions.maxRange, this.precisionLimit);
                }
                else {
                    return MathHelper.roundToPrecisionLimit(this.viewLowValue + this.viewOptions.maxRange, this.precisionLimit);
                }
            }
        }
        return newValue;
    };
    SliderComponent.prototype.applyPushRange = function (newValue) {
        var difference = this.tracking === HandleType.Low
            ? this.viewHighValue - newValue
            : newValue - this.viewLowValue;
        var minRange = this.viewOptions.minRange !== null
            ? this.viewOptions.minRange
            : this.viewOptions.step;
        var maxRange = this.viewOptions.maxRange;
        if (difference < minRange) {
            if (this.tracking === HandleType.Low) {
                this.viewHighValue = MathHelper.roundToPrecisionLimit(Math.min(newValue + minRange, this.maxValue), this.precisionLimit);
                newValue = MathHelper.roundToPrecisionLimit(this.viewHighValue - minRange, this.precisionLimit);
                this.applyHighValue();
                this.updateHandles(HandleType.High, this.valueToPosition(this.viewHighValue));
            }
            else {
                this.viewLowValue = MathHelper.roundToPrecisionLimit(Math.max(newValue - minRange, this.minValue), this.precisionLimit);
                newValue = MathHelper.roundToPrecisionLimit(this.viewLowValue + minRange, this.precisionLimit);
                this.applyLowValue();
                this.updateHandles(HandleType.Low, this.valueToPosition(this.viewLowValue));
            }
            this.updateAriaAttributes();
        }
        else if (maxRange !== null && difference > maxRange) {
            if (this.tracking === HandleType.Low) {
                this.viewHighValue = MathHelper.roundToPrecisionLimit(newValue + maxRange, this.precisionLimit);
                this.applyHighValue();
                this.updateHandles(HandleType.High, this.valueToPosition(this.viewHighValue));
            }
            else {
                this.viewLowValue = MathHelper.roundToPrecisionLimit(newValue - maxRange, this.precisionLimit);
                this.applyLowValue();
                this.updateHandles(HandleType.Low, this.valueToPosition(this.viewLowValue));
            }
            this.updateAriaAttributes();
        }
        return newValue;
    };
    SliderComponent.prototype.applyModel = function (callUserChange) {
        this.internalChange = true;
        this.valueChange.emit(this.value);
        this.highValueChange.emit(this.highValue);
        if (callUserChange) {
            this.userChange.emit(this.getChangeContext());
        }
        if (this.onChangeCallback) {
            if (this.range) {
                this.onChangeCallback([this.value, this.highValue]);
            }
            else {
                this.onChangeCallback(this.value);
            }
        }
        if (this.onTouchedCallback) {
            if (this.range) {
                this.onTouchedCallback([this.value, this.highValue]);
            }
            else {
                this.onTouchedCallback(this.value);
            }
        }
        this.internalChange = false;
    };
    SliderComponent.prototype.getChangeContext = function () {
        var changeContext = new ChangeContext();
        changeContext.pointerType = this.tracking === HandleType.Low ? PointerType.Min : PointerType.Max;
        changeContext.value = this.value;
        changeContext.highValue = this.highValue;
        return changeContext;
    };
    return SliderComponent;
}());
SliderComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'ng5-slider',
                template: "<!-- // 0 (left) Highlight outside two handles -->\n<span ng5SliderLeftOutSelElem class=\"ng5-slider-span ng5-slider-bar-wrapper ng5-slider-left-out-selection\">\n  <span class=\"ng5-slider-span ng5-slider-bar\"></span>\n</span>\n<!-- // 1 (right) Highlight outside two handles -->\n<span ng5SliderRightOutSelElem class=\"ng5-slider-span ng5-slider-bar-wrapper ng5-slider-right-out-selection\">\n  <span class=\"ng5-slider-span ng5-slider-bar\"></span>\n</span>\n<!-- // 2 The slider bar -->\n<span ng5SliderFullBarElem class=\"ng5-slider-span ng5-slider-bar-wrapper\">\n  <span class=\"ng5-slider-span ng5-slider-bar\"></span>\n</span>\n<!-- // 3 Highlight between two handles -->\n<span ng5SliderSelBarElem class=\"ng5-slider-span ng5-slider-bar-wrapper\">\n  <span class=\"ng5-slider-span ng5-slider-bar ng5-slider-selection\" [ngStyle]=\"barStyle\"></span>\n</span>\n<!-- // 4 Left slider handle -->\n<span ng5SliderMinHElem class=\"ng5-slider-span ng5-slider-pointer ng5-slider-pointer-min\" [ngStyle]=minPointerStyle></span>\n<!-- // 5 Right slider handle -->\n<span ng5SliderMaxHElem class=\"ng5-slider-span ng5-slider-pointer ng5-slider-pointer-max\" [ngStyle]=maxPointerStyle></span>\n<!-- // 6 Floor label -->\n<span ng5SliderFlrLabElem class=\"ng5-slider-span ng5-slider-bubble ng5-slider-limit ng5-slider-floor\"></span>\n<!-- // 7 Ceiling label -->\n<span ng5SliderCeilLabElem class=\"ng5-slider-span ng5-slider-bubble ng5-slider-limit ng5-slider-ceil\"></span>\n<!-- // 8 Label above left slider handle -->\n<span ng5SliderMinLabElem class=\"ng5-slider-span ng5-slider-bubble ng5-slider-model-value\"></span>\n<!-- // 9 Label above right slider handle -->\n<span ng5SliderMaxLabElem class=\"ng5-slider-span ng5-slider-bubble ng5-slider-model-high\"></span>\n<!-- // 10 Range label when the slider handles are close ex. 15 - 17 -->\n<span ng5SliderCmbLabElem class=\"ng5-slider-span ng5-slider-bubble ng5-slider-combined\"></span>\n<!-- // 11 The ticks -->\n<span ng5SliderTicksElem [hidden]=\"!showTicks\" class=\"ng5-slider-ticks\">\n  <span *ngFor=\"let t of ticks\" class=\"ng5-slider-tick\" [ngClass]=\"{'ng5-slider-selected': t.selected}\" [ngStyle]=\"t.style\">\n    <ng5-slider-tooltip-wrapper [template]=\"tooltipTemplate\" [tooltip]=\"t.tooltip\" [placement]=\"t.tooltipPlacement\"></ng5-slider-tooltip-wrapper>\n    <ng5-slider-tooltip-wrapper *ngIf=\"t.value != null\" class=\"ng5-slider-span ng5-slider-tick-value\"\n        [template]=\"tooltipTemplate\" [tooltip]=\"t.valueTooltip\" [placement]=\"t.valueTooltipPlacement\" [content]=\"t.value\"></ng5-slider-tooltip-wrapper>\n    <span *ngIf=\"t.legend != null\" class=\"ng5-slider-span ng5-slider-tick-legend\">{{ t.legend }}</span>\n  </span>\n</span>",
                styles: ["::ng-deep .ng5-slider{display:inline-block;position:relative;height:4px;width:100%;margin:35px 0 15px;vertical-align:middle;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-ms-touch-action:pan-y;touch-action:pan-y}::ng-deep .ng5-slider.with-legend{margin-bottom:40px}::ng-deep .ng5-slider[disabled]{cursor:not-allowed}::ng-deep .ng5-slider[disabled] .ng5-slider-pointer{cursor:not-allowed;background-color:#d8e0f3}::ng-deep .ng5-slider[disabled] .ng5-slider-draggable{cursor:not-allowed}::ng-deep .ng5-slider[disabled] .ng5-slider-selection{background:#8b91a2}::ng-deep .ng5-slider[disabled] .ng5-slider-tick{cursor:not-allowed}::ng-deep .ng5-slider[disabled] .ng5-slider-tick.ng5-slider-selected{background:#8b91a2}::ng-deep .ng5-slider .ng5-slider-span{white-space:nowrap;position:absolute;display:inline-block}::ng-deep .ng5-slider .ng5-slider-base{width:100%;height:100%;padding:0}::ng-deep .ng5-slider .ng5-slider-bar-wrapper{left:0;-webkit-box-sizing:border-box;box-sizing:border-box;margin-top:-16px;padding-top:16px;width:100%;height:32px;z-index:1}::ng-deep .ng5-slider .ng5-slider-draggable{cursor:move}::ng-deep .ng5-slider .ng5-slider-bar{left:0;width:100%;height:4px;z-index:1;background:#d8e0f3;border-radius:2px}::ng-deep .ng5-slider .ng5-slider-bar-wrapper.ng5-slider-transparent .ng5-slider-bar{background:0 0}::ng-deep .ng5-slider .ng5-slider-bar-wrapper.ng5-slider-left-out-selection .ng5-slider-bar{background:#df002d}::ng-deep .ng5-slider .ng5-slider-bar-wrapper.ng5-slider-right-out-selection .ng5-slider-bar{background:#03a688}::ng-deep .ng5-slider .ng5-slider-selection{z-index:2;background:#0db9f0;border-radius:2px}::ng-deep .ng5-slider .ng5-slider-pointer{cursor:pointer;width:32px;height:32px;top:-14px;background-color:#0db9f0;z-index:3;border-radius:16px}::ng-deep .ng5-slider .ng5-slider-pointer:after{content:'';width:8px;height:8px;position:absolute;top:12px;left:12px;border-radius:4px;background:#fff}::ng-deep .ng5-slider .ng5-slider-pointer:hover:after{background-color:#fff}::ng-deep .ng5-slider .ng5-slider-pointer.ng5-slider-active{z-index:4}::ng-deep .ng5-slider .ng5-slider-pointer.ng5-slider-active:after{background-color:#451aff}::ng-deep .ng5-slider .ng5-slider-bubble{cursor:default;bottom:16px;padding:1px 3px;color:#55637d;font-size:16px}::ng-deep .ng5-slider .ng5-slider-bubble.ng5-slider-limit{color:#55637d}::ng-deep .ng5-slider .ng5-slider-ticks{-webkit-box-sizing:border-box;box-sizing:border-box;width:100%;height:0;position:absolute;left:0;top:-3px;margin:0;z-index:1;list-style:none}::ng-deep .ng5-slider .ng5-slider-ticks-values-under .ng5-slider-tick-value{top:auto;bottom:-36px}::ng-deep .ng5-slider .ng5-slider-tick{text-align:center;cursor:pointer;width:10px;height:10px;background:#d8e0f3;border-radius:50%;position:absolute;top:0;left:0;margin-left:11px}::ng-deep .ng5-slider .ng5-slider-tick.ng5-slider-selected{background:#0db9f0}::ng-deep .ng5-slider .ng5-slider-tick-value{position:absolute;top:-34px;-webkit-transform:translate(-50%,0);transform:translate(-50%,0)}::ng-deep .ng5-slider .ng5-slider-tick-legend{position:absolute;top:24px;-webkit-transform:translate(-50%,0);transform:translate(-50%,0);max-width:50px;white-space:normal}::ng-deep .ng5-slider.ng5-slider-vertical{position:relative;width:4px;height:100%;margin:0 20px;padding:0;vertical-align:baseline;-ms-touch-action:pan-x;touch-action:pan-x}::ng-deep .ng5-slider.ng5-slider-vertical .ng5-slider-base{width:100%;height:100%;padding:0}::ng-deep .ng5-slider.ng5-slider-vertical .ng5-slider-bar-wrapper{top:auto;left:0;margin:0 0 0 -16px;padding:0 0 0 16px;height:100%;width:32px}::ng-deep .ng5-slider.ng5-slider-vertical .ng5-slider-bar{bottom:0;left:auto;width:4px;height:100%}::ng-deep .ng5-slider.ng5-slider-vertical .ng5-slider-pointer{left:-14px!important;top:auto;bottom:0}::ng-deep .ng5-slider.ng5-slider-vertical .ng5-slider-bubble{left:16px!important;bottom:0}::ng-deep .ng5-slider.ng5-slider-vertical .ng5-slider-ticks{height:100%;width:0;left:-3px;top:0;z-index:1}::ng-deep .ng5-slider.ng5-slider-vertical .ng5-slider-tick{vertical-align:middle;margin-left:auto;margin-top:11px}::ng-deep .ng5-slider.ng5-slider-vertical .ng5-slider-tick-value{left:24px;top:auto;-webkit-transform:translate(0,-28%);transform:translate(0,-28%)}::ng-deep .ng5-slider.ng5-slider-vertical .ng5-slider-tick-legend{top:auto;right:24px;-webkit-transform:translate(0,-28%);transform:translate(0,-28%);max-width:none;white-space:nowrap}::ng-deep .ng5-slider.ng5-slider-vertical .ng5-slider-ticks-values-under .ng5-slider-tick-value{bottom:auto;left:auto;right:24px}"],
                host: { class: 'ng5-slider' },
                providers: [NG5_SLIDER_CONTROL_VALUE_ACCESSOR]
            },] },
];
SliderComponent.ctorParameters = function () { return [
    { type: core.Renderer2, },
    { type: core.ElementRef, },
    { type: core.ChangeDetectorRef, },
]; };
SliderComponent.propDecorators = {
    "value": [{ type: core.Input },],
    "valueChange": [{ type: core.Output },],
    "highValue": [{ type: core.Input },],
    "highValueChange": [{ type: core.Output },],
    "userChangeStart": [{ type: core.Output },],
    "userChange": [{ type: core.Output },],
    "userChangeEnd": [{ type: core.Output },],
    "options": [{ type: core.Input },],
    "manualRefresh": [{ type: core.Input },],
    "leftOutSelBar": [{ type: core.ViewChild, args: [LeftOutSelDirective,] },],
    "rightOutSelBar": [{ type: core.ViewChild, args: [RightOutSelDirective,] },],
    "fullBarElem": [{ type: core.ViewChild, args: [FullBarDirective,] },],
    "selBarElem": [{ type: core.ViewChild, args: [SelBarDirective,] },],
    "minHElem": [{ type: core.ViewChild, args: [MinHDirective,] },],
    "maxHElem": [{ type: core.ViewChild, args: [MaxHDirective,] },],
    "flrLabElem": [{ type: core.ViewChild, args: [FlrLabDirective,] },],
    "ceilLabElem": [{ type: core.ViewChild, args: [CeilLabDirective,] },],
    "minLabElem": [{ type: core.ViewChild, args: [MinLabDirective,] },],
    "maxLabElem": [{ type: core.ViewChild, args: [MaxLabDirective,] },],
    "cmbLabElem": [{ type: core.ViewChild, args: [CmbLabDirective,] },],
    "ticksElem": [{ type: core.ViewChild, args: [TicksDirective,] },],
    "tooltipTemplate": [{ type: core.ContentChild, args: ['tooltipTemplate',] },],
    "sliderElementVerticalClass": [{ type: core.HostBinding, args: ['class.ng5-slider-vertical',] },],
    "sliderElementDisabledAttr": [{ type: core.HostBinding, args: ['attr.disabled',] },],
    "onResize": [{ type: core.HostListener, args: ['window:resize', ['$event'],] },],
};
var TooltipWrapperComponent = /** @class */ (function () {
    function TooltipWrapperComponent() {
    }
    return TooltipWrapperComponent;
}());
TooltipWrapperComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'ng5-slider-tooltip-wrapper',
                template: "<ng-container *ngIf=\"template\">\n  <ng-template *ngTemplateOutlet=\"template; context: {tooltip: tooltip, placement: placement, content: content}\"></ng-template>\n</ng-container>\n\n<ng-container *ngIf=\"!template\">\n  <div class=\"ng5-slider-inner-tooltip\" [attr.title]=\"tooltip\" [attr.data-tooltip-placement]=\"placement\">\n    {{content}}\n  </div>\n</ng-container>",
                styles: [".ng5-slider-inner-tooltip{height:100%}"]
            },] },
];
TooltipWrapperComponent.ctorParameters = function () { return []; };
TooltipWrapperComponent.propDecorators = {
    "template": [{ type: core.Input },],
    "tooltip": [{ type: core.Input },],
    "placement": [{ type: core.Input },],
    "content": [{ type: core.Input },],
};
var Ng5SliderModule = /** @class */ (function () {
    function Ng5SliderModule() {
    }
    return Ng5SliderModule;
}());
Ng5SliderModule.decorators = [
    { type: core.NgModule, args: [{
                imports: [
                    common.CommonModule
                ],
                declarations: [
                    SliderComponent,
                    RightOutSelDirective,
                    LeftOutSelDirective,
                    FullBarDirective,
                    SelBarDirective,
                    MinHDirective,
                    MaxHDirective,
                    FlrLabDirective,
                    CeilLabDirective,
                    MinLabDirective,
                    MaxLabDirective,
                    CmbLabDirective,
                    TicksDirective,
                    TooltipWrapperComponent
                ],
                exports: [
                    SliderComponent
                ]
            },] },
];
Ng5SliderModule.ctorParameters = function () { return []; };

exports.Ng5SliderModule = Ng5SliderModule;
exports.ChangeContext = ChangeContext;
exports.PointerType = PointerType;
exports.LabelType = LabelType;
exports.Options = Options;
exports.o = JqLiteWrapper;
exports.i = CeilLabDirective;
exports.l = CmbLabDirective;
exports.h = FlrLabDirective;
exports.d = FullBarDirective;
exports.c = LeftOutSelDirective;
exports.g = MaxHDirective;
exports.k = MaxLabDirective;
exports.f = MinHDirective;
exports.j = MinLabDirective;
exports.b = RightOutSelDirective;
exports.e = SelBarDirective;
exports.n = SliderComponent;
exports.a = SliderElement;
exports.m = TicksDirective;
exports.p = TooltipWrapperComponent;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ng5-slider.umd.js.map
